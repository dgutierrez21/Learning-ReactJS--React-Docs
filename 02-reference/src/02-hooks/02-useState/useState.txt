useState
useState es un React Hook que le permite agregar una variable de estado a su componente.

const [state, setState] = useState(initialState)

Referencia

useState(initialState)
Llame a useState en el nivel superior del componente para declarar una variable de estado.
import { useState } from 'react';

function MyComponent() {
  const [age, setAge] = useState(28);
  const [name, setName] = useState('Taylor');
  const [todos, setTodos] = useState(() => createTodos());
  // ...

La convenci√≥n es nombrar variables de estado como [something, setSomething] usando la desestructuraci√≥n de matrices.

Par√°metros
-- initialState: el valor que desea que sea el estado inicialmente. Puede ser un valor de cualquier tipo, pero hay un comportamiento especial para las funciones. Este argumento se omite despu√©s de la representaci√≥n inicial.
    --Si pasa una funci√≥n como initialState, se tratar√° como una funci√≥n inicializadora. Debe ser puro, no debe aceptar argumentos y debe devolver un valor de cualquier tipo. React llamar√° a su funci√≥n inicializador al inicializar el componente y almacenar√° su valor devuelto como el estado inicial. Vea un ejemplo a continuaci√≥n.

Devuelve
useState devuelve una matriz con exactamente dos valores:

El estado actual. Durante el primer renderizado, coincidir√° con el initialState que ha pasado.

La funci√≥n set que le permite actualizar el estado a un valor diferente y desencadenar una rerepresentaci√≥n.

Advertencias
-- useState es un Hook, por lo que solo puede llamarlo en el nivel superior de su componente o en sus propios Hooks. No puedes llamarlo dentro de bucles o condiciones. Si necesita eso, extraiga un nuevo componente y mueva el estado a √©l.

--En el modo estricto, React llamar√° a la funci√≥n de su inicializador dos veces para ayudarlo a encontrar impurezas accidentales. Este es un comportamiento de solo desarrollo y no afecta la producci√≥n. Si la funci√≥n del inicializador es pura (como deber√≠a ser), esto no deber√≠a afectar a la l√≥gica del componente. Se ignorar√° el resultado de una de las llamadas.

funciones set, como setSomething(nextState)
La funci√≥n set devuelta por useState le permite actualizar el estado a un valor diferente y desencadenar una nueva representaci√≥n. Puede pasar el siguiente estado directamente o una funci√≥n que lo calcule a partir del estado anterior:

const [name, setName] = useState('Edward');

function handleClick() {
  setName('Taylor');
  setAge(a => a + 1);
  // ...

Par√°metros
-- nextState: el valor que desea que sea el estado. Puede ser un valor de cualquier tipo, pero hay un comportamiento especial para las funciones.
    -- Si pasa una funci√≥n como nextState, se tratar√° como una funci√≥n de actualizaci√≥n. Debe ser puro, debe tomar el estado pendiente como su √∫nico argumento y debe devolver el siguiente estado. React pondr√° su funci√≥n de actualizaci√≥n en una cola y volver√° a renderizar su componente. Durante el siguiente renderizado, React calcular√° el siguiente estado aplicando todos los actualizadores en cola al estado anterior. Vea un ejemplo a continuaci√≥n.

Devuelve
set no tienen un valor devuelto.

Advertencias
--La funci√≥n set s√≥lo actualiza la variable de estado para el siguiente renderizado. Si lee la variable de estado despu√©s de llamar a la funci√≥n set, seguir√° obteniendo el valor anterior que estaba en la pantalla antes de la llamada.

--Si el nuevo valor que proporciona es id√©ntico al state actual, seg√∫n lo determinado por una comparaci√≥n Object.is, React omitir√° volver a renderizar el componente y sus hijos. Esto es una optimizaci√≥n. Aunque en algunos casos React todav√≠a puede necesitar llamar a su componente antes de omitir los hijos, no deber√≠a afectar su c√≥digo.

--Reaccionar lotes de actualizaciones de estado. Actualiza la pantalla despu√©s de que todos los controladores de eventos se hayan ejecutado y hayan llamado a sus funciones set. Esto evita m√∫ltiples reprocesamientos durante un solo evento. En el raro caso de que necesite forzar a React a actualizar la pantalla antes, por ejemplo, para acceder al DOM, puede usar flushSync.

--Solo se permite llamar a la funci√≥n set durante la representaci√≥n desde el componente de representaci√≥n actual. React descartar√° su salida e inmediatamente intentar√° renderizarla nuevamente con el nuevo estado. Este patr√≥n rara vez es necesario, pero puede usarlo para almacenar informaci√≥n de los renders anteriores. Vea un ejemplo a continuaci√≥n.

--En el modo estricto, React llamar√° a su funci√≥n de actualizaci√≥n dos veces para ayudarlo a encontrar impurezas accidentales. Este es un comportamiento de solo desarrollo y no afecta la producci√≥n. Si la funci√≥n del actualizador es pura (como deber√≠a ser), esto no deber√≠a afectar a la l√≥gica del componente. Se ignorar√° el resultado de una de las llamadas.

Uso 
Agregar estado a un componente
Llame a useState en el nivel superior del componente para declarar una o m√°s variables de estado.

import { useState } from 'react';

function MyComponent() {
  const [age, setAge] = useState(42);
  const [name, setName] = useState('Taylor');
  // ...

La convenci√≥n es nombrar variables de estado como [something, setSomething] usando la desestructuraci√≥n de matrices.

useState devuelve una matriz con exactamente dos elementos:

1. El Estado actual de esta variable de estado, establecida inicialmente en el Estado inicial usted proporcion√≥.
2. El set funci√≥n Eso le permite cambiarlo a cualquier otro valor en respuesta a la interacci√≥n.
Para actualizar lo que est√° en la pantalla, llame a la funci√≥n set con el siguiente estado:

function handleClick() {
  setName('Robin');
}

React almacenar√° el siguiente estado, renderizar√° su componente nuevamente con los nuevos valores y actualizar√° la interfaz de usuario.

Atenci√≥n
Llamar a la funci√≥n set no cambia el estado actual en el c√≥digo que ya se est√° ejecutando:

function handleClick() {
  setName('Robin');
  console.log(name); // Still "Taylor"!
}

Solo afecta a lo que useState devolver√° a partir del siguiente renderizado.

Uso b√°sico

Ejemplos de estados

Ejemplo 1 de 4: Contador (n√∫mero)
En este ejemplo, la variable de estado count contiene un n√∫mero. Al hacer clic en el bot√≥n, se incrementa.

Ejemplo 2 de 4: Campo de texto (cadena)
En este ejemplo, la variable de estado text contiene una cadena. Cuando escribes, handleChange lee el √∫ltimo valor de entrada del elemento DOM de entrada del navegador, y llama a setText para actualizar el estado. Esto permite mostrar el texto actual a continuaci√≥n.

Ejemplo 3 de 4: Checkbox (boolean)
En este ejemplo, la variable de estado liked contiene un booleano. Cuando haces clic en la entrada, setLiked actualiza la variable de estado liked con si la entrada de la casilla de verificaci√≥n del navegador est√° marcada. La variable liked se utiliza para mostrar el texto debajo de la casilla de verificaci√≥n.

Ejemplo 4 de 4: Formulario (dos variables)
Se puede declarar m√°s de una variable de estado en el mismo componente. Cada variable de estado es completamente independiente.

Actualizaci√≥n del estado basado en el estado anterior
Supongamos que la edad es 42 age. Este controlador llama a setAge(age + 1) tres veces:

function handleClick() {
  setAge(age + 1); // setAge(42 + 1)
  setAge(age + 1); // setAge(42 + 1)
  setAge(age + 1); // setAge(42 + 1)
}

Sin embargo, despu√©s de un clic, age solo ser√° 43 a√±os en lugar de 45! Esto se debe a que al llamar a la funci√≥n set no se actualiza la variable de estado de age en el c√≥digo que ya se est√° ejecutando. As√≠ que cada llamada setAge(setAge(age + 1)) se convierte en setAge(43).

Para resolver este problema, puede pasar una funci√≥n de actualizaci√≥n a setAge en lugar del siguiente estado:

function handleClick() {
  setAge(a => a + 1); // setAge(42 => 43)
  setAge(a => a + 1); // setAge(43 => 44)
  setAge(a => a + 1); // setAge(44 => 45)
}

Aqu√≠, a a => a + 1 es su funci√≥n de actualizaci√≥n. Se necesita el Estado pendiente y calcula el Siguiente estado de ella.

React pone sus funciones de actualizaci√≥n en una cola. Luego, durante el siguiente renderizado, los llamar√° en el mismo orden:

1. a a => a + 1 recibir√° 42 como estado pendiente y devolver√° 43 como estado siguiente.
2. a a => a + 1 recibir√° 43 como estado pendiente y devolver√° 44 como estado siguiente.
3. a a => a + 1 recibir√° 44 como estado pendiente y devolver√° 45 como estado siguiente.

No hay otras actualizaciones en cola, por lo que React almacenar√° 45 como el estado actual al final.

Por convenci√≥n, es com√∫n nombrar el argumento de estado pendiente para la primera letra del nombre de la variable de estado, como a para age. Sin embargo, tambi√©n puede llamarlo como prevAge u otra cosa que encuentre m√°s clara.

React puede llamar a sus actualizadores dos veces en el desarrollo para verificar que son puros.

La diferencia entre pasar un actualizador y pasar el siguiente estado directamente

Ejemplo 1 de 2: Pasar la funci√≥n del actualizador
Este ejemplo pasa la funci√≥n updater, por lo que el bot√≥n "+3" funciona.

Ejemplo 2 de 2: Pasar el siguiente estado directamente
Este ejemplo no pasa la funci√≥n actualizadora, por lo que el bot√≥n "+3" no funciona como se pretende.

Actualizaci√≥n de objetos y matrices en estado
Puede poner objetos y matrices en estado. En React, el estado se considera de solo lectura, por lo que debe reemplazarlo en lugar de mutar los objetos existentes. Por ejemplo, si tiene un objeto form en estado, no lo actualice as√≠:

// üö© Don't mutate an object in state like this:
form.firstName = 'Taylor';
En su lugar, reemplace todo el objeto creando uno nuevo:

// ‚úÖ Replace state with a new object
setForm({
  ...form,
  firstName: 'Taylor'
});
Lea actualizaci√≥n de objetos en estado y actualizaci√≥n de matrices en estado para obtener m√°s informaci√≥n.

Ejemplos de objetos y matrices en estado

Ejemplo 1 de 4: Formulario (objeto)
En este ejemplo, la variable de estado de form contiene un objeto. Cada entrada tiene un controlador de cambios que llama a setForm con el siguiente estado de todo el formulario. El { ...form } spread garantiza que el objeto de estado se reemplace en lugar de mutar.

Ejemplo 2 de 4: Formulario (objeto anidado)
En este ejemplo, el estado est√° m√°s anidado. Cuando actualizas un estado anidado, necesitas crear una copia del objeto que est√°s actualizando, as√≠ como de cualquier objeto que lo "contenga" en el camino hacia arriba. Lee actualizar un objeto anidado para saber m√°s. https://beta.es.reactjs.org/learn/updating-objects-in-state#updating-a-nested-object

Ejemplo 3 de 4: Lista (array)
En este ejemplo, la variable de estado todos contiene un array. Cada manejador de bot√≥n llama a setTodos con la siguiente versi√≥n de ese array. La sintaxis de propagaci√≥n [...todos], todos.map() y todos.filter() aseguran que el array de estado sea reemplazado en lugar de mutado.

Ejemplo 4 de 4: Escribir l√≥gica de actualizaci√≥n concisa con Immer
Si actualizar arrays y objetos sin mutaci√≥n te parece tedioso, puedes usar una librer√≠a como Immer para reducir el c√≥digo repetitivo. Immer te permite escribir c√≥digo conciso como si estuvieras mutando objetos, pero bajo el cap√≥ realiza actualizaciones inmutables:

Evitar volver a crear el estado inicial
React guarda el estado inicial una vez y lo ignora en los siguientes renders.

function TodoList() {
  const [todos, setTodos] = useState(createInitialTodos());
  // ...

Aunque el resultado de createInitialTodos() solo se usa para el renderizado inicial, todav√≠a est√° llamando a esta funci√≥n en cada renderizado. Esto puede ser un desperdicio si se trata de crear grandes matrices o realizar c√°lculos costosos.

Para resolver esto, puede pasarlo como una funci√≥n inicializadora a useState en su lugar:

function TodoList() {
  const [todos, setTodos] = useState(createInitialTodos);
  // ...

Observe que est√° pasando createInitialTodos, que es la funci√≥n en s√≠, y no createInitialTodos(), que es el resultado de llamarlo.createInitialTodos Si pasa una funci√≥n a useState, React solo la llamar√° durante la inicializaci√≥n.

React puede llamar a sus inicializadores dos veces en el desarrollo para verificar que son puros.

Restablecimiento del estado con una clave
Normalmente, es posible que encuentre el atributo key al representar listas. Sin embargo, tambi√©n sirve para otro prop√≥sito.

Puede restablecer el estado de un componente pasando una key diferente a un componente. En este ejemplo, el bot√≥n Restablecer cambia la variable de estado de version, que pasamos como key al Form. Cuando la key cambia, React vuelve a crear el componente Form (y todos sus hijos) desde cero, por lo que su estado se restablece.

Lea Preservar y restablecer el estado para obtener m√°s informaci√≥n.
https://beta.es.reactjs.org/learn/preserving-and-resetting-state

...

Almacenamiento de informaci√≥n de renders anteriores
Normalmente, actualizar√° el estado en los controladores de eventos. Sin embargo, en raras ocasiones, es posible que desee ajustar el estado en respuesta a la representaci√≥n; por ejemplo, es posible que desee cambiar una variable de estado cuando cambia un accesorio.

En la mayor√≠a de los casos, no necesita esto:

  --Si el valor que necesita se puede calcular completamente a partir de los accesorios actuales u otro estado, elimine ese estado redundante por completo. Si le preocupa volver a computar con demasiada frecuencia, useMemo Hook puede ayudarlo.

  --Si desea restablecer el estado de todo el √°rbol de componentes, pase una key diferente al componente.

  --Si puede, actualice todo el estado relevante en los controladores de eventos.

En el raro caso de que no se aplique ninguna de estas condiciones, hay un patr√≥n que puede utilizar para actualizar el estado en funci√≥n de los valores que se han representado hasta ahora, llamando a una funci√≥n set mientras se representa el componente.

Aqu√≠ hay un ejemplo. Este componente CountLabel muestra el accesorio count que se le ha pasado:

export default function CountLabel({ count }) {
  return <h1>{count}</h1>
}

Supongamos que desea mostrar si el contador ha aumentado o disminuido desde el √∫ltimo cambio. El accesorio de count no le dice esto: debe realizar un seguimiento de su valor anterior. Agregue la variable de estado prevCount para realizar un seguimiento de ella. Agregue otra variable de estado llamada trend para mantener si el recuento ha aumentado o disminuido. Compare prevCount con count y, si no son iguales, actualice tanto prevCount como prevCount.trend Ahora puede mostrar tanto el accesorio de recuento actual como c√≥mo ha cambiado desde el √∫ltimo renderizado.

...

Tenga en cuenta que si llama a una funci√≥n set durante la representaci√≥n, debe estar dentro de una condici√≥n como prevCount !== count count, y debe haber una llamada como setPrevCount(count) dentro de la condici√≥n. De lo contrario, el componente se volver√≠a a representar en un bucle hasta que se bloquee. Adem√°s, solo puede actualizar el estado del componente de representaci√≥n actual de esta manera. Llamar a la funci√≥n set de otro componente durante la representaci√≥n es un error. Finalmente, su llamada set a√∫n debe actualizar el estado sin mutaci√≥n; este caso especial no significa que pueda romper otras reglas de funciones puras.

Este patr√≥n puede ser dif√≠cil de entender y generalmente es mejor evitarlo. Sin embargo, es mejor que actualizar el estado en un efecto. Cuando llame a la funci√≥n set durante el renderizado, React volver√° a renderizar ese componente inmediatamente despu√©s de que su componente salga con una instrucci√≥n return y antes de renderizar los hijos. De esta manera, los ni√±os no necesitan renderizar dos veces. El resto de la funci√≥n de su componente seguir√° ejecut√°ndose (y el resultado se desechar√°), pero si su condici√≥n est√° por debajo de todas las llamadas a Hooks, puede agregar un return; dentro de √©l para reiniciar el renderizado antes.

Soluci√≥n de problemas
He actualizado el estado, pero el registro me da el valor anterior
Llamar a la funci√≥n set no cambia de estado en el c√≥digo en ejecuci√≥n:

function handleClick() {
  console.log(count);  // 0

  setCount(count + 1); // Request a re-render with 1
  console.log(count);  // Still 0!

  setTimeout(() => {
    console.log(count); // Also 0!
  }, 5000)
  ;
}

Esto se debe a que los estados se comportan como una instant√°nea. La actualizaci√≥n del estado solicita otra representaci√≥n con el nuevo valor de estado, pero no afecta a la variable JavaScript count en el controlador de eventos que ya se est√° ejecutando.

Si necesita usar el siguiente estado, puede guardarlo en una variable antes de pasarlo a la funci√≥n set:

const nextCount = count + 1;
setCount(nextCount);

console.log(count);     // 0
console.log(nextCount); // 1