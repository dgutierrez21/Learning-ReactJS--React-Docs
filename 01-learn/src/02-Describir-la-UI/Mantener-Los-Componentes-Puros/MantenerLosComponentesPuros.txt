Mantener los componentes puros
Algunas funciones de JavaScript son puras. Las funciones puras solo realizan un cálculo y nada más. Al escribir estrictamente tus componentes como funciones puras, puedes evitar una clase completa de errores desconcertantes y un comportamiento impredecible a medida que crece tu base de código. Sin embargo, para obtener estos beneficios, hay algunas reglas que debes seguir.

Aprenderás
Qué es la pureza y cómo te ayuda a evitar errores
Cómo mantener los componentes puros manteniendo los cambios fuera de la fase de renderizado
Cómo usar el modo estricto para encontrar errores en tus componentes

Pureza: componentes como fórmulas 
En informática (y especialmente en el mundo de la programación funcional), una función pura es una función con las siguientes características:

Se ocupa de sus propios asuntos. No cambia ningún objeto o variable que existiera antes de ser llamado.
Las mismas entradas, la misma salida. Dadas las mismas entradas, una función pura siempre debe devolver el mismo resultado.
Es posible que ya estés familiarizado con un ejemplo de funciones puras: fórmulas en matemáticas.

Considera esta fórmula matemática: y = 2x.

Si x = 2 entonces y = 4. Siempre.

Si x = 3 entonces y = 6. Siempre.

Si x = 3, y a veces no será 9 o –1 o 2.5 dependiendo de la hora del día o del estado del mercado de valores.

Si y = 2x y x = 3, y siempre será 6.

Si convirtiéramos esto en una función de JavaScript, se vería así:

function double(number) {
  return 2 * number;
}
En el ejemplo anterior, double es una función pura. Si le pasas 3, devolverá 6. Siempre.

React está diseñado en torno a este concepto. React supone que cada componente que escribes es una función pura. Esto significa que los componentes que escribes en React siempre deben devolver el mismo JSX dadas las mismas entradas:

Cuando pasas drinkers={2} a Recipe, devolverá el JSX que contiene 2 cups of water. Siempre.

Si pasas drinkers={4}, devolverá el JSX que contiene 4 cups of water. Siempre.

Como una fórmula matemática.

Puedes pensar en tus componentes como recetas: si las sigues y no agregas nuevos ingredientes durante el proceso de cocción, obtendrás el mismo plato siempre. Ese “plato” es el JSX que el componente le pasa a React para renderizar.

Efectos secundarios: consecuencias (no)deseadas 
El proceso de renderizado de React siempre debe ser puro. Los componentes solo deben retornar su JSX, y no cambiar cualquier objeto o variable que existiera antes de renderizar: ¡Eso los haría impuros!

Aquí hay un componente que rompe esta regla:

Este componente está leyendo y escribiendo una variable guest declarada fuera de ella. Esto significa que llamar a este componente varias veces producirá diferente JSX! Y lo que es más, si otros componentes leen guest, también producirán diferente JSX, ¡dependiendo de cuándo se procesaron! Eso no es predecible.

Volviendo a nuestra fórmula y = 2x, ahora incluso si x = 2, no podemos confiar en que y = 4. Nuestras pruebas podrían fallar, nuestros usuarios estarían desconcertados, los aviones se caerían del cielo —¡puedes ver cómo esto conduciría a errores confusos!

Puedes arreglar este componente pasando guest como prop en su lugar:

Ahora tu componente ya es puro, ya que el JSX que devuelve solo depende de la prop invitados.

En general, no debes esperar que tus componentes se rendericen en ningún orden en particular. No importa si llamas y = 2x antes o después y = 5x: ambas fórmulas se resolverán independientemente una de la otra. Del mismo modo, cada componente solo debe “pensar por sí mismo” y no intentar coordinarse o depender de otros durante el renderizado. El renderizado es como un examen escolar: ¡cada componente debe calcular su JSX por su cuenta!