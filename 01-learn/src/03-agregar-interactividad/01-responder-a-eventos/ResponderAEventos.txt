Responder a eventos
React te permite añadir manejadores de eventos a tu JSX. Los manejadores de eventos son tus propias funciones que se ejecutarán en respuesta a interacciones como hacer clic, hover, enfocar inputs en formularios, entre otras.

Aprenderás
Diferentes maneras de escribir un manejador de eventos
Cómo pasar la lógica de manejo de eventos desde un componente padre
Cómo los eventos se propagan y cómo detenerlos

Añadiendo manejadores de eventos 
Para agregar un manejador de eventos, primero definirás una función y luego la pasarás como una prop a la etiqueta JSX apropiada. Por ejemplo, este es un botón que no hace nada todavía:

...

Puedes hacer que muestre un mensaje cuando un usuario haga clic siguiendo estos tres pasos:

1. Declara una función llamada handleClick dentro de tu componente Button.
2. Implementa la lógica dentro de esa función (utiliza alert para mostrar el mensaje).
3. Agrega onClick={handleClick} al JSX del <button>.

Definiste la función handleClick y luego la pasaste como una prop al <button>.  handleClick es un manejador de eventos. Las funciones manejadoras de eventos:

Usualmente están definidas dentro de tus componentes.
Tienen nombres que empiezan con handle, seguido del nombre del evento.
Por convención, es común llamar a los manejadores de eventos como handle seguido del nombre del evento. A menudo verás onClick={handleClick}, onMouseEnter={handleMouseEnter}, etcétera.

Por otro lado, puedes definir un manejador de eventos en línea en el JSX:

Todos estos estilos son equivalentes. Los manejadores de eventos en línea son convenientes para funciones cortas.

Atención
Las funciones que se pasan a los manejadores de eventos deben ser pasadas, no llamadas. Por ejemplo:

pasar una función (correcto)	llamar una función (incorrecto)
<button onClick={handleClick}>	<button onClick={handleClick()}>

La diferencia es sutil. En el primer ejemplo, la función handleClick es pasada como un manejador de evento onClick. Esto le dice a React que lo recuerde y solo llama la función cuando el usuario hace clic en el botón.

En el segundo ejemplo, los () al final del handleClick() ejecutan la función inmediatamente mientras se renderiza, sin ningún clic. Esto es porque el JavaScript dentro de { y } en JSX se ejecuta de inmediato.

Cuando escribes código en línea, la misma trampa se presenta de otra manera:

pasar una función (correcto)	llamar una función (incorrecto)
<button onClick={() => alert('...')}>	<button onClick={alert('...')}>

Pasar código en línea así no lo ejecutará al hacer clic; lo ejecutará cada vez que el componente se renderice:

// Esta alerta se ejecuta cuando el componente se renderiza, ¡no cuando se hace clic!
<button onClick={alert('¡Me cliqueaste!')}>

Si quieres definir un manejador de evento en línea, envuélvelo en una función anónima de esta forma:

<button onClick={() => alert('¡Me cliqueaste!')}>

En lugar de ejecutar el código que está dentro cada vez que se renderiza, esto crea una función para que se llame más tarde.

En ambos casos, lo que quieres pasar es una función:

<button onClick={handleClick}> pasa la función handleClick.
<button onClick={() => alert('...')}> pasa la función () => alert('...').

---Leyendo las props en manejadores de eventos---
Como los manejadores de eventos son declarados dentro de un componente, tienen acceso a las props del componente. Este es  un botón que, cuando recibe el clic, muestra una alerta con su prop message:

...

Esto le permite a estos dos botones mostrar diferentes mensajes. Intenta cambiar los mensajes que se les pasan.

Pasar manejadores de eventos como props 
A menudo querrás que el componente padre especifique un manejador de eventos de un componente hijo. Considera unos botones: dependiendo de dónde estás usando un componente Button, es posible que quieras ejecutar una función diferente, tal vez una reproduzca una película y otra cargue una imagen.

Para hacer esto, pasa una prop que el componente recibe de su padre como el manejador eventos así:

...

Aquí, el componente Toolbar renderiza un PlayButton y un UploadButton:

PlayButton pasa handlePlayClick como la prop onClick al Button que está dentro.
UploadButton pasa () => alert('Uploading!') como la prop onClick al Button que está dentro.
Finalmente, tu componente Button acepta una prop llamada onClick. Pasa esa prop directamente al <button> integrado en el navegador con onClick={onClick}. Esto le dice a React que llame la función pasada cuando reciba un clic.

Si usas un sistema de diseño( shorturl.at/iouL6 ), es común para componentes como los botones que contengan estilos pero no especifiquen un comportamiento. En cambio, componentes como PlayButton y UploadButton pasarán los manejadores de eventos.

Nombrar props de manejadores de eventos 
Componentes integrados como <button> y <div> solo admiten nombres de eventos del navegador como onClick. Sin embargo, cuando estás creando tus propios componentes, puedes nombrar sus props de manejador de eventos como quieras.

Por convención, las props de manejadores de eventos deberían empezar con on, seguido de una letra mayúscula.

Por ejemplo, la propiedad onClick del componente Button pudo haberse llamado onSmash:

...

En este ejemplo, <button onClick={onSmash}> muestra que el <button> (minúsculas) del navegador todavía necesita una prop llamada onClick, ¡pero el nombre de la prop recibida por tu componente Button personalizado depende de ti!

Cuando tu componente admite múltiples interacciones, podrías nombrar las props de manejadores de eventos para conceptos específicos de la aplicación. Por ejemplo, este componente Toolbar recibe los manejadores de eventos de onPlayMovie y onUploadImage:

Fíjate como el componente App no necesita saber qué hará Toolbar con onPlayMovie o onUploadImage. Eso es un detalle de implementación del Toolbar. Aquí, Toolbar los pasa como manejadores onClick en sus Buttons, pero podría luego iniciarlos con un atajo de teclado. Nombrar props a partir de interacciones específicas de la aplicación como onPlayMovie te da la flexibilidad de cambiar cómo se usan más tarde.