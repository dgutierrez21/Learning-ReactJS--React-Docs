Separar eventos de efectos
Los controladores de eventos solo se vuelven a ejecutar cuando se vuelve a realizar la misma interacción. A diferencia de los controladores de eventos, los efectos se vuelven a sincronizar si algún valor que leen, como un prop o una variable de estado, es diferente del que era durante la última representación. A veces, también desea una mezcla de ambos comportamientos: un efecto que se vuelve a ejecutar en respuesta a algunos valores pero no a otros. Esta página le enseñará cómo hacerlo.

Aprenderás
Cómo elegir entre un controlador de eventos y un efecto
Por qué los efectos son reactivos y los controladores de eventos no
Qué hacer cuando desea que una parte del código de su efecto no sea reactiva
Qué son los eventos de efecto y cómo extraerlos de los efectos
Cómo leer los últimos accesorios y el estado de Efectos mediante eventos de efectos

Elegir entre controladores de eventos y efectos
En primer lugar, recapitulemos la diferencia entre los controladores de eventos y Effects.

Imagine que está implementando un componente de salón de chat. Sus requisitos se ven así:

    1. El componente debe conectarse automáticamente al salón de chat seleccionado.
    2. Cuando haga clic en el botón "Enviar", debería enviar un mensaje al chat.

Digamos que ya ha implementado el código para ellos, pero no está seguro de dónde colocarlo. ¿Debería usar controladores de eventos o Effects? Cada vez que necesite responder a esta pregunta, considere por qué debe ejecutarse el código( https://acortar.link/9FCMN5 )

Los controladores de eventos se ejecutan en respuesta a interacciones específicas
Desde la perspectiva del usuario, el envío de un mensaje debe ocurrir porque se hizo clic en el botón "Enviar" en particular. El usuario se molestará bastante si envía su mensaje en cualquier otro momento o por cualquier otra razón. Esta es la razón por la que enviar un mensaje debe ser un controlador de eventos. Los controladores de eventos le permiten controlar interacciones específicas, como clics:

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');
  // ...
  function handleSendClick() {
    sendMessage(message);
  }
  // ...
  return (
    <>
      <input value={message} onChange={e => setMessage(e.target.value)} />
      <button onClick={handleSendClick}>Send</button>;
    </>
  );
}

Con un controlador de eventos, puede estar seguro de que sendMessage(message) solo se ejecutará si el usuario presiona el botón.

Los efectos se ejecutan siempre que se necesita sincronización
Recuerde que también debe mantener el componente conectado a la sala de chat. ¿A dónde va ese código?

La razón para ejecutar este código no es una interacción particular. No importa por qué o cómo el usuario navegó a la pantalla del salón de chat. Ahora que lo están mirando y pueden interactuar con él, el componente debe permanecer conectado al servidor de chat seleccionado. Incluso si el componente de salón de chat era la pantalla inicial de la aplicación y el usuario no ha realizado ninguna interacción, aún necesitaría conectarse. Es por eso que es un efecto:

function ChatRoom({ roomId }) {
  // ...
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]);
  // ...
}

Con este código, puede estar seguro de que siempre hay una conexión activa con el servidor de chat seleccionado actualmente, independientemente de las interacciones específicas realizadas por el usuario. Tanto si el usuario solo ha abierto la aplicación, seleccionado una sala diferente o navegado a otra pantalla y viceversa, el efecto garantizará que el componente permanezca sincronizado con la sala seleccionada actualmente y se volverá a conectar siempre que sea necesario.

Valores reactivos y lógica reactiva
Intuitivamente, se podría decir que los controladores de eventos siempre se activan "manualmente", por ejemplo, haciendo clic en un botón. Los efectos, por otro lado, son "automáticos": se ejecutan y vuelven a ejecutar con la frecuencia necesaria para mantenerse sincronizados.

Hay una manera más precisa de pensar sobre esto.

Los accesorios, el estado y las variables declaradas dentro del cuerpo del componente se denominan Valores reactivos. En este ejemplo, serverUrl no es un valor reactivo, pero roomId y message sí lo son. Participan en el flujo de datos de representación:

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  // ...
}

Los valores reactivos como estos pueden cambiar debido a un reprocesamiento. Por ejemplo, el usuario puede editar el message o elegir un roomId diferente en un menú desplegable. Los controladores de eventos y los efectos son diferentes en la forma en que responden a los cambios:

    --La lógica dentro de los controladores de eventos no es reactiva. No se volverá a ejecutar a menos que el usuario vuelva a realizar la misma interacción (por ejemplo, un clic). Los controladores de eventos pueden leer valores reactivos, pero no "reaccionan" a sus cambios.
    
    --La lógica dentro de Efectos es reactiva. Si el efecto lee un valor reactivo, debe especificarlo como una dependencia. Luego, si un re-renderizado hace que ese valor cambie, React volverá a ejecutar la lógica de su efecto nuevamente con el nuevo valor.

Volvamos al ejemplo anterior para ilustrar esta diferencia.

La lógica dentro de los controladores de eventos no es reactiva
Echa un vistazo a esta línea de código. ¿Debería esta lógica ser reactiva o no?

    // ...
    sendMessage(message);
    // ...

Desde la perspectiva del usuario, un cambio en el mensaje no significa que quiera enviar un message. Solo significa que el usuario está escribiendo. En otras palabras, la lógica que envía un mensaje no debe ser reactiva. No debe volver a ejecutarse solo porque el Valor reactivo ha cambiado. Es por eso que colocó esta lógica en el controlador de eventos:

  function handleSendClick() {
    sendMessage(message);
  }
  
Los controladores de eventos no son reactivos, por lo que sendMessage(message) solo se ejecutará cuando el usuario haga clic en el botón Enviar.

La lógica dentro de Efectos es reactiva
Ahora volvamos a estas líneas:

    // ...
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    // ...

Desde la perspectiva del usuario, un cambio en el roomId significa que desea conectarse a una habitación diferente. En otras palabras, la lógica para conectarse a la habitación debe ser reactiva. Desea que estas líneas de código "se mantengan al día" con el Valor reactivoy volver a ejecutarse si ese valor es diferente. Es por eso que pones esta lógica dentro de un efecto:

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect()
    };
  }, [roomId]);
  
Los efectos son reactivos, por lo que createConnection(serverUrl, roomId) roomId) y connection.connect() se ejecutarán para cada valor distinto de roomId. Su efecto mantiene la conexión de chat sincronizada con la sala seleccionada actualmente.

Extracción de lógica no reactiva de Effects
Las cosas se ponen más complicadas cuando se quiere mezclar lógica reactiva con lógica no reactiva.

Por ejemplo, imagine que desea mostrar una notificación cuando el usuario se conecta al chat. Lees el tema actual (oscuro o claro) de los accesorios para que puedas mostrar la notificación en el color correcto:

function ChatRoom({ roomId, theme }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      showNotification('Connected!', theme);
    });
    connection.connect();
    // ...

Sin embargo, theme es un valor reactivo (puede cambiar como resultado de la rerepresentación), y cada valor reactivo leído por un efecto debe declararse como su dependencia. Así que ahora tienes que especificar el theme como una dependencia de tu Efecto:

function ChatRoom({ roomId, theme }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      showNotification('Connected!', theme);
    });
    connection.connect();
    return () => {
      connection.disconnect()
    };
  }, [roomId, theme]); // ✅ All dependencies declared
  // ...

Juegue con este ejemplo y vea si puede detectar el problema con esta experiencia de usuario:

...

Cuando el roomId cambia, el chat se vuelve a conectar como cabría esperar. Pero como el tema también es una dependencia, el chat también se vuelve a conectar cada vez que cambias entre el theme oscuro y el claro. ¡Eso no es genial!

En otras palabras, no desea que esta línea sea reactiva, aunque esté dentro de un efecto (que es reactivo):

      // ...
      showNotification('Connected!', theme);
      // ...
      
Necesita una forma de separar esta lógica no reactiva del efecto reactivo que la rodea.