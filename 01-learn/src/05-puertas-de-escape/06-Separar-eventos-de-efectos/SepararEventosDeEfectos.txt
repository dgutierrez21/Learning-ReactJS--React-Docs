Separar eventos de efectos
Los controladores de eventos solo se vuelven a ejecutar cuando se vuelve a realizar la misma interacción. A diferencia de los controladores de eventos, los efectos se vuelven a sincronizar si algún valor que leen, como un prop o una variable de estado, es diferente del que era durante la última representación. A veces, también desea una mezcla de ambos comportamientos: un efecto que se vuelve a ejecutar en respuesta a algunos valores pero no a otros. Esta página le enseñará cómo hacerlo.

Aprenderás
Cómo elegir entre un controlador de eventos y un efecto
Por qué los efectos son reactivos y los controladores de eventos no
Qué hacer cuando desea que una parte del código de su efecto no sea reactiva
Qué son los eventos de efecto y cómo extraerlos de los efectos
Cómo leer los últimos accesorios y el estado de Efectos mediante eventos de efectos

Elegir entre controladores de eventos y efectos
En primer lugar, recapitulemos la diferencia entre los controladores de eventos y Effects.

Imagine que está implementando un componente de salón de chat. Sus requisitos se ven así:

    1. El componente debe conectarse automáticamente al salón de chat seleccionado.
    2. Cuando haga clic en el botón "Enviar", debería enviar un mensaje al chat.

Digamos que ya ha implementado el código para ellos, pero no está seguro de dónde colocarlo. ¿Debería usar controladores de eventos o Effects? Cada vez que necesite responder a esta pregunta, considere por qué debe ejecutarse el código( https://acortar.link/9FCMN5 )

Los controladores de eventos se ejecutan en respuesta a interacciones específicas
Desde la perspectiva del usuario, el envío de un mensaje debe ocurrir porque se hizo clic en el botón "Enviar" en particular. El usuario se molestará bastante si envía su mensaje en cualquier otro momento o por cualquier otra razón. Esta es la razón por la que enviar un mensaje debe ser un controlador de eventos. Los controladores de eventos le permiten controlar interacciones específicas, como clics:

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');
  // ...
  function handleSendClick() {
    sendMessage(message);
  }
  // ...
  return (
    <>
      <input value={message} onChange={e => setMessage(e.target.value)} />
      <button onClick={handleSendClick}>Send</button>;
    </>
  );
}

Con un controlador de eventos, puede estar seguro de que sendMessage(message) solo se ejecutará si el usuario presiona el botón.