Separar eventos de efectos
Los controladores de eventos solo se vuelven a ejecutar cuando se vuelve a realizar la misma interacción. A diferencia de los controladores de eventos, los efectos se vuelven a sincronizar si algún valor que leen, como un prop o una variable de estado, es diferente del que era durante la última representación. A veces, también desea una mezcla de ambos comportamientos: un efecto que se vuelve a ejecutar en respuesta a algunos valores pero no a otros. Esta página le enseñará cómo hacerlo.

Aprenderás
Cómo elegir entre un controlador de eventos y un efecto
Por qué los efectos son reactivos y los controladores de eventos no
Qué hacer cuando desea que una parte del código de su efecto no sea reactiva
Qué son los eventos de efecto y cómo extraerlos de los efectos
Cómo leer los últimos accesorios y el estado de Efectos mediante eventos de efectos

Elegir entre controladores de eventos y efectos
En primer lugar, recapitulemos la diferencia entre los controladores de eventos y Effects.

Imagine que está implementando un componente de salón de chat. Sus requisitos se ven así:

    1. El componente debe conectarse automáticamente al salón de chat seleccionado.
    2. Cuando haga clic en el botón "Enviar", debería enviar un mensaje al chat.

Digamos que ya ha implementado el código para ellos, pero no está seguro de dónde colocarlo. ¿Debería usar controladores de eventos o Effects? Cada vez que necesite responder a esta pregunta, considere por qué debe ejecutarse el código( https://acortar.link/9FCMN5 )

Los controladores de eventos se ejecutan en respuesta a interacciones específicas
Desde la perspectiva del usuario, el envío de un mensaje debe ocurrir porque se hizo clic en el botón "Enviar" en particular. El usuario se molestará bastante si envía su mensaje en cualquier otro momento o por cualquier otra razón. Esta es la razón por la que enviar un mensaje debe ser un controlador de eventos. Los controladores de eventos le permiten controlar interacciones específicas, como clics:

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');
  // ...
  function handleSendClick() {
    sendMessage(message);
  }
  // ...
  return (
    <>
      <input value={message} onChange={e => setMessage(e.target.value)} />
      <button onClick={handleSendClick}>Send</button>;
    </>
  );
}

Con un controlador de eventos, puede estar seguro de que sendMessage(message) solo se ejecutará si el usuario presiona el botón.

Los efectos se ejecutan siempre que se necesita sincronización
Recuerde que también debe mantener el componente conectado a la sala de chat. ¿A dónde va ese código?

La razón para ejecutar este código no es una interacción particular. No importa por qué o cómo el usuario navegó a la pantalla del salón de chat. Ahora que lo están mirando y pueden interactuar con él, el componente debe permanecer conectado al servidor de chat seleccionado. Incluso si el componente de salón de chat era la pantalla inicial de la aplicación y el usuario no ha realizado ninguna interacción, aún necesitaría conectarse. Es por eso que es un efecto:

function ChatRoom({ roomId }) {
  // ...
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]);
  // ...
}

Con este código, puede estar seguro de que siempre hay una conexión activa con el servidor de chat seleccionado actualmente, independientemente de las interacciones específicas realizadas por el usuario. Tanto si el usuario solo ha abierto la aplicación, seleccionado una sala diferente o navegado a otra pantalla y viceversa, el efecto garantizará que el componente permanezca sincronizado con la sala seleccionada actualmente y se volverá a conectar siempre que sea necesario.

Valores reactivos y lógica reactiva
Intuitivamente, se podría decir que los controladores de eventos siempre se activan "manualmente", por ejemplo, haciendo clic en un botón. Los efectos, por otro lado, son "automáticos": se ejecutan y vuelven a ejecutar con la frecuencia necesaria para mantenerse sincronizados.

Hay una manera más precisa de pensar sobre esto.

Los accesorios, el estado y las variables declaradas dentro del cuerpo del componente se denominan Valores reactivos. En este ejemplo, serverUrl no es un valor reactivo, pero roomId y message sí lo son. Participan en el flujo de datos de representación:

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  // ...
}

Los valores reactivos como estos pueden cambiar debido a un reprocesamiento. Por ejemplo, el usuario puede editar el message o elegir un roomId diferente en un menú desplegable. Los controladores de eventos y los efectos son diferentes en la forma en que responden a los cambios:

    --La lógica dentro de los controladores de eventos no es reactiva. No se volverá a ejecutar a menos que el usuario vuelva a realizar la misma interacción (por ejemplo, un clic). Los controladores de eventos pueden leer valores reactivos, pero no "reaccionan" a sus cambios.
    
    --La lógica dentro de Efectos es reactiva. Si el efecto lee un valor reactivo, debe especificarlo como una dependencia. Luego, si un re-renderizado hace que ese valor cambie, React volverá a ejecutar la lógica de su efecto nuevamente con el nuevo valor.

Volvamos al ejemplo anterior para ilustrar esta diferencia.