Separar eventos de efectos
Los controladores de eventos solo se vuelven a ejecutar cuando se vuelve a realizar la misma interacci√≥n. A diferencia de los controladores de eventos, los efectos se vuelven a sincronizar si alg√∫n valor que leen, como un prop o una variable de estado, es diferente del que era durante la √∫ltima representaci√≥n. A veces, tambi√©n desea una mezcla de ambos comportamientos: un efecto que se vuelve a ejecutar en respuesta a algunos valores pero no a otros. Esta p√°gina le ense√±ar√° c√≥mo hacerlo.

Aprender√°s
C√≥mo elegir entre un controlador de eventos y un efecto
Por qu√© los efectos son reactivos y los controladores de eventos no
Qu√© hacer cuando desea que una parte del c√≥digo de su efecto no sea reactiva
Qu√© son los eventos de efecto y c√≥mo extraerlos de los efectos
C√≥mo leer los √∫ltimos accesorios y el estado de Efectos mediante eventos de efectos

Elegir entre controladores de eventos y efectos
En primer lugar, recapitulemos la diferencia entre los controladores de eventos y Effects.

Imagine que est√° implementando un componente de sal√≥n de chat. Sus requisitos se ven as√≠:

    1. El componente debe conectarse autom√°ticamente al sal√≥n de chat seleccionado.
    2. Cuando haga clic en el bot√≥n "Enviar", deber√≠a enviar un mensaje al chat.

Digamos que ya ha implementado el c√≥digo para ellos, pero no est√° seguro de d√≥nde colocarlo. ¬øDeber√≠a usar controladores de eventos o Effects? Cada vez que necesite responder a esta pregunta, considere por qu√© debe ejecutarse el c√≥digo( https://acortar.link/9FCMN5 )

Los controladores de eventos se ejecutan en respuesta a interacciones espec√≠ficas
Desde la perspectiva del usuario, el env√≠o de un mensaje debe ocurrir porque se hizo clic en el bot√≥n "Enviar" en particular. El usuario se molestar√° bastante si env√≠a su mensaje en cualquier otro momento o por cualquier otra raz√≥n. Esta es la raz√≥n por la que enviar un mensaje debe ser un controlador de eventos. Los controladores de eventos le permiten controlar interacciones espec√≠ficas, como clics:

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');
  // ...
  function handleSendClick() {
    sendMessage(message);
  }
  // ...
  return (
    <>
      <input value={message} onChange={e => setMessage(e.target.value)} />
      <button onClick={handleSendClick}>Send</button>;
    </>
  );
}

Con un controlador de eventos, puede estar seguro de que sendMessage(message) solo se ejecutar√° si el usuario presiona el bot√≥n.

Los efectos se ejecutan siempre que se necesita sincronizaci√≥n
Recuerde que tambi√©n debe mantener el componente conectado a la sala de chat. ¬øA d√≥nde va ese c√≥digo?

La raz√≥n para ejecutar este c√≥digo no es una interacci√≥n particular. No importa por qu√© o c√≥mo el usuario naveg√≥ a la pantalla del sal√≥n de chat. Ahora que lo est√°n mirando y pueden interactuar con √©l, el componente debe permanecer conectado al servidor de chat seleccionado. Incluso si el componente de sal√≥n de chat era la pantalla inicial de la aplicaci√≥n y el usuario no ha realizado ninguna interacci√≥n, a√∫n necesitar√≠a conectarse. Es por eso que es un efecto:

function ChatRoom({ roomId }) {
  // ...
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]);
  // ...
}

Con este c√≥digo, puede estar seguro de que siempre hay una conexi√≥n activa con el servidor de chat seleccionado actualmente, independientemente de las interacciones espec√≠ficas realizadas por el usuario. Tanto si el usuario solo ha abierto la aplicaci√≥n, seleccionado una sala diferente o navegado a otra pantalla y viceversa, el efecto garantizar√° que el componente permanezca sincronizado con la sala seleccionada actualmente y se volver√° a conectar siempre que sea necesario.

Valores reactivos y l√≥gica reactiva
Intuitivamente, se podr√≠a decir que los controladores de eventos siempre se activan "manualmente", por ejemplo, haciendo clic en un bot√≥n. Los efectos, por otro lado, son "autom√°ticos": se ejecutan y vuelven a ejecutar con la frecuencia necesaria para mantenerse sincronizados.

Hay una manera m√°s precisa de pensar sobre esto.

Los accesorios, el estado y las variables declaradas dentro del cuerpo del componente se denominan Valores reactivos. En este ejemplo, serverUrl no es un valor reactivo, pero roomId y message s√≠ lo son. Participan en el flujo de datos de representaci√≥n:

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  // ...
}

Los valores reactivos como estos pueden cambiar debido a un reprocesamiento. Por ejemplo, el usuario puede editar el message o elegir un roomId diferente en un men√∫ desplegable. Los controladores de eventos y los efectos son diferentes en la forma en que responden a los cambios:

    --La l√≥gica dentro de los controladores de eventos no es reactiva. No se volver√° a ejecutar a menos que el usuario vuelva a realizar la misma interacci√≥n (por ejemplo, un clic). Los controladores de eventos pueden leer valores reactivos, pero no "reaccionan" a sus cambios.
    
    --La l√≥gica dentro de Efectos es reactiva. Si el efecto lee un valor reactivo, debe especificarlo como una dependencia. Luego, si un re-renderizado hace que ese valor cambie, React volver√° a ejecutar la l√≥gica de su efecto nuevamente con el nuevo valor.

Volvamos al ejemplo anterior para ilustrar esta diferencia.

La l√≥gica dentro de los controladores de eventos no es reactiva
Echa un vistazo a esta l√≠nea de c√≥digo. ¬øDeber√≠a esta l√≥gica ser reactiva o no?

    // ...
    sendMessage(message);
    // ...

Desde la perspectiva del usuario, un cambio en el mensaje no significa que quiera enviar un message. Solo significa que el usuario est√° escribiendo. En otras palabras, la l√≥gica que env√≠a un mensaje no debe ser reactiva. No debe volver a ejecutarse solo porque el Valor reactivo ha cambiado. Es por eso que coloc√≥ esta l√≥gica en el controlador de eventos:

  function handleSendClick() {
    sendMessage(message);
  }
  
Los controladores de eventos no son reactivos, por lo que sendMessage(message) solo se ejecutar√° cuando el usuario haga clic en el bot√≥n Enviar.

La l√≥gica dentro de Efectos es reactiva
Ahora volvamos a estas l√≠neas:

    // ...
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    // ...

Desde la perspectiva del usuario, un cambio en el roomId significa que desea conectarse a una habitaci√≥n diferente. En otras palabras, la l√≥gica para conectarse a la habitaci√≥n debe ser reactiva. Desea que estas l√≠neas de c√≥digo "se mantengan al d√≠a" con el Valor reactivoy volver a ejecutarse si ese valor es diferente. Es por eso que pones esta l√≥gica dentro de un efecto:

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect()
    };
  }, [roomId]);
  
Los efectos son reactivos, por lo que createConnection(serverUrl, roomId) roomId) y connection.connect() se ejecutar√°n para cada valor distinto de roomId. Su efecto mantiene la conexi√≥n de chat sincronizada con la sala seleccionada actualmente.

Extracci√≥n de l√≥gica no reactiva de Effects
Las cosas se ponen m√°s complicadas cuando se quiere mezclar l√≥gica reactiva con l√≥gica no reactiva.

Por ejemplo, imagine que desea mostrar una notificaci√≥n cuando el usuario se conecta al chat. Lees el tema actual (oscuro o claro) de los accesorios para que puedas mostrar la notificaci√≥n en el color correcto:

function ChatRoom({ roomId, theme }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      showNotification('Connected!', theme);
    });
    connection.connect();
    // ...

Sin embargo, theme es un valor reactivo (puede cambiar como resultado de la rerepresentaci√≥n), y cada valor reactivo le√≠do por un efecto debe declararse como su dependencia. As√≠ que ahora tienes que especificar el theme como una dependencia de tu Efecto:

function ChatRoom({ roomId, theme }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      showNotification('Connected!', theme);
    });
    connection.connect();
    return () => {
      connection.disconnect()
    };
  }, [roomId, theme]); // ‚úÖ All dependencies declared
  // ...

Juegue con este ejemplo y vea si puede detectar el problema con esta experiencia de usuario:

...

Cuando el roomId cambia, el chat se vuelve a conectar como cabr√≠a esperar. Pero como el tema tambi√©n es una dependencia, el chat tambi√©n se vuelve a conectar cada vez que cambias entre el theme oscuro y el claro. ¬°Eso no es genial!

En otras palabras, no desea que esta l√≠nea sea reactiva, aunque est√© dentro de un efecto (que es reactivo):

      // ...
      showNotification('Connected!', theme);
      // ...
      
Necesita una forma de separar esta l√≥gica no reactiva del efecto reactivo que la rodea.

Declaraci√≥n de un evento de efecto
Nota: 
En esta secci√≥n se describe una API experimental que a√∫n no se ha agregado a React, por lo que a√∫n no puede usarla.

Utilice un gancho especial llamado useEffectEvent para extraer esta l√≥gica no reactiva de su efecto:

import { useEffect, useEffectEvent } from 'react';

function ChatRoom({ roomId, theme }) {
  const onConnected = useEffectEvent(() => {
    showNotification('Connected!', theme);
  });
  // ...
  
Aqu√≠, onConnected se denomina evento de efecto. Es parte de la l√≥gica de Effect, pero se comporta mucho m√°s como un controlador de eventos. La l√≥gica dentro de √©l no es reactiva, y siempre "ve" los √∫ltimos valores de sus accesorios y estado.

Ahora puede llamar al evento de efecto onConnected desde dentro de su efecto:

function ChatRoom({ roomId, theme }) {
  const onConnected = useEffectEvent(() => {
    showNotification('Connected!', theme);
  });

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.on('connected', () => {
      onConnected();
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ‚úÖ All dependencies declared
  // ...

Esto resuelve el problema. Tenga en cuenta que tuvo que eliminar onConnected de la lista de dependencias de su efecto. Los eventos de efecto no son reactivos y deben omitirse de las dependencias. El linter se equivocar√° si los incluye.

Compruebe que el nuevo comportamiento funciona como cabr√≠a esperar:

ver en https://codesandbox.io/s/bd0s8d?file=/package.json&utm_medium=sandpack

Puede pensar que los eventos de efecto son muy similares a los controladores de eventos. La principal diferencia es que los controladores de eventos se ejecutan en respuesta a las interacciones de un usuario, mientras que los eventos de efecto son activados por usted desde Effects. Los eventos de efecto le permiten "romper la cadena" entre la reactividad de los efectos y alg√∫n c√≥digo que no deber√≠a ser reactivo.

Leer los √∫ltimos accesorios y el estado con eventos de efecto
Nota
En esta secci√≥n se describe una API experimental que a√∫n no se ha agregado a React, por lo que a√∫n no puede usarla.

Los eventos de efecto le permiten corregir muchos patrones en los que podr√≠a tener la tentaci√≥n de suprimir el l√≠mite de dependencias.

Por ejemplo, supongamos que tiene un efecto para registrar las visitas a la p√°gina:

function Page() {
  useEffect(() => {
    logVisit();
  }, []);
  // ...
}

M√°s tarde, agregar√° varias rutas a su sitio. Ahora el componente Page recibe una url prop con la ruta actual. Desea pasar la url como parte de la llamada logVisit, pero el linter de dependencia se queja:

function Page({ url }) {
  useEffect(() => {
    logVisit(url);
  }, []); // üî¥ React Hook useEffect has a missing dependency: 'url'
  // ...
}

Piensa en lo que quieres que haga el c√≥digo. Desea registrar una visita independiente para diferentes URL, ya que cada URL representa una p√°gina diferente. En otras palabras, esta llamada logVisit debe ser reactiva con respecto a la url. Esta es la raz√≥n por la que, en este caso, tiene sentido seguir el l√≠mite de dependencias y agregar url como dependencia:

function Page({ url }) {
  useEffect(() => {
    logVisit(url);
  }, [url]); // ‚úÖ All dependencies declared
  // ...
}

Ahora digamos que desea incluir el n√∫mero de art√≠culos en el carrito de compras junto con cada visita a la p√°gina:

function Page({ url }) {
  const { items } = useContext(ShoppingCartContext);
  const numberOfItems = items.length;

  useEffect(() => {
    logVisit(url, numberOfItems);
  }, [url]); // üî¥ React Hook useEffect has a missing dependency: 'numberOfItems'
  // ...
}

Ha utilizado numberOfItems dentro del efecto, por lo que el linter le pide que lo agregue como una dependencia. Sin embargo, no desea que la llamada logVisit sea reactiva con respecto a numberOfItems. Si el usuario pone algo en el carrito de compras y el numberOfItems cambia, esto no significa que el usuario haya visitado la p√°gina nuevamente. En otras palabras, visitar la p√°gina se siente similar a un evento. Quieres ser muy preciso sobre cu√°ndo dices que sucedi√≥.

Divide el c√≥digo en dos partes:

function Page({ url }) {
  const { items } = useContext(ShoppingCartContext);
  const numberOfItems = items.length;

  const onVisit = useEffectEvent(visitedUrl => {
    logVisit(visitedUrl, numberOfItems);
  });

  useEffect(() => {
    onVisit(url);
  }, [url]); // ‚úÖ All dependencies declared
  // ...
}

Aqu√≠, onVisit es un evento de efecto. El c√≥digo que contiene no es reactivo. Esta es la raz√≥n por la que puede usar numberOfItems (¬°o cualquier otro valor reactivo!) sin preocuparse de que haga que el c√≥digo circundante se vuelva a ejecutar en los cambios.

Por otro lado, el efecto en s√≠ sigue siendo reactivo. El c√≥digo dentro del efecto utiliza la url prop, por lo que el efecto se volver√° a ejecutar despu√©s de cada re-renderizado con una url diferente. Esto, a su vez, llamar√° al evento onVisit Effect.

Como resultado, llamar√° a logVisit para cada cambio en la url y siempre leer√° el numberOfItems. Sin embargo, si numberOfItems cambia por s√≠ solo, esto no har√° que se vuelva a ejecutar nada del c√≥digo.

Nota
Es posible que se pregunte si podr√≠a llamar a onVisit() sin argumentos y leer la url dentro de √©l:

  const onVisit = useEffectEvent(() => {
    logVisit(url, numberOfItems);
  });

  useEffect(() => {
    onVisit();
  }, [url]);

Esto funcionar√≠a, pero es mejor pasar esta url al evento de efecto expl√≠citamente. Al pasar url url como argumento a su evento de efecto, est√° diciendo que visitar una p√°gina con una url diferente constituye un "evento" separado desde la perspectiva del usuario. La visitedUrl es una parte del "evento" que sucedi√≥:

  const onVisit = useEffectEvent(visitedUrl => {
    logVisit(visitedUrl, numberOfItems);
  });

  useEffect(() => {
    onVisit(url);
  }, [url]);

Dado que su evento de efecto "pide" expl√≠citamente la url visitedUrl, ahora no puede eliminar accidentalmente la url de las dependencias del efecto. Si elimina la dependencia de url (lo que hace que las distintas visitas url se cuenten como una), el linter le advertir√° al respecto. Desea que onVisit sea reactivo con respecto a la url, por lo que en lugar de url leer la url dentro (donde no ser√≠a reactiva), la pasa de su efecto.

Esto se vuelve especialmente importante si hay alguna l√≥gica as√≠ncrona dentro del efecto:

  const onVisit = useEffectEvent(visitedUrl => {
    logVisit(visitedUrl, numberOfItems);
  });

  useEffect(() => {
    setTimeout(() => {
      onVisit(url);
    }, 5000); // Delay logging visits
  }, [url]);

En este url dentro de onVisit corresponde a la url URL m√°s reciente (que ya podr√≠a haber cambiado), pero visitedUrl corresponde a la url que originalmente caus√≥ que se ejecutara este efecto (y esta llamada onVisit).