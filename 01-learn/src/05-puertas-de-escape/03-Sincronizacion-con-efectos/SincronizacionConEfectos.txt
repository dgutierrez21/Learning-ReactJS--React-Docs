Sincronización con efectos
Algunos componentes necesitan sincronizarse con sistemas externos. Por ejemplo, es posible que desee controlar un componente que no sea de React en función del estado React, configurar una conexión de servidor o enviar un registro de análisis cuando aparezca un componente en la pantalla. Los efectos le permiten ejecutar código después de la representación para que pueda sincronizar su componente con algún sistema fuera de React.

Aprenderás
¿Qué efectos son?
En qué se diferencian los efectos de los eventos
Cómo declarar un efecto en el componente
Cómo omitir volver a ejecutar un efecto innecesariamente
Por qué los efectos se ejecutan dos veces en desarrollo y cómo solucionarlos

¿Qué son los efectos y en qué se diferencian de los eventos?
Antes de llegar a Effects, debe estar familiarizado con dos tipos de lógica dentro de los componentes de React:

El código de representación (introducido en Descripción de la interfaz de usuario) reside en el nivel superior del componente. Aquí es donde tomas los accesorios y el estado, los transformas y devuelves el JSX que deseas ver en la pantalla. El código de representación debe ser puro. Al igual que una fórmula matemática, solo debe calcular el resultado, pero no hacer nada más.

Los controladores de eventos (introducidos en Agregar interactividad) son funciones anidadas dentro de los componentes que hacen cosas en lugar de simplemente calcularlas. Un controlador de eventos puede actualizar un campo de entrada, enviar una solicitud HTTP POST para comprar un producto o llevar al usuario a otra pantalla. Los controladores de eventos contienen "efectos secundarios" (cambian el estado del programa) y son causados por una acción específica del usuario (por ejemplo, un clic en el botón o escribir).

A veces esto no es suficiente. Considere un componente de salón de chat que debe conectarse al servidor ChatRoom siempre que esté visible en la pantalla. Conectarse a un servidor no es un cálculo puro (es un efecto secundario), por lo que no puede ocurrir durante el renderizado. Sin embargo, no hay un solo evento en particular, como un clic, que haga que se muestre ChatRoom.

Los efectos permiten especificar los efectos secundarios causados por la representación en sí, en lugar de por un evento determinado. Enviar un mensaje en el chat es un evento porque es causado directamente por el usuario haciendo clic en un botón específico. Sin embargo, la configuración de una conexión de servidor es un efecto porque debe ocurrir independientemente de qué interacción haya provocado la aparición del componente. Los efectos se ejecutan al final del proceso de renderizado después de que se actualice la pantalla. Este es un buen momento para sincronizar los componentes de React con algún sistema externo (como una red o una biblioteca de terceros).

Nota
Aquí y más adelante en este texto, "Efecto" en mayúscula se refiere a la definición específica de React anterior, es decir, un efecto secundario causado por la representación. Para referirnos al concepto de programación más amplio, diremos "efecto secundario".

Es posible que no necesites un efecto
No se apresure a agregar efectos a sus componentes. Tenga en cuenta que los efectos generalmente se usan para "salir" de su código de React y sincronizarse con algún sistema externo. Esto incluye API de navegador, widgets de terceros, red, etc. Si su Efecto solo ajusta algún estado en función de otro estado, es posible que no necesite un Efecto.

Cómo escribir un efecto
Para escribir un efecto, siga estos tres pasos:

1 .Declarar un efecto. De forma predeterminada, el efecto se ejecutará después de cada renderizado.

2. Especifique las dependencias de efecto. La mayoría de los efectos solo deben volver a ejecutarse cuando sea necesario en lugar de después de cada renderizado. Por ejemplo, una animación de fundido solo debe activarse cuando aparece un componente. La conexión y desconexión a un salón de chat solo debe ocurrir cuando el componente aparece y desaparece, o cuando cambia el salón de chat. Aprenderá a controlar esto especificando dependencias.

3. Agregue limpieza si es necesario. Algunos efectos necesitan especificar cómo detener, deshacer o limpiar lo que estaban haciendo. Por ejemplo, "conectar" necesita "desconectar", "suscribirse" necesita "cancelar suscripción" y "buscar" necesita "cancelar" o "ignorar". Aprenderá cómo hacerlo devolviendo una función de limpieza.

Veamos cada uno de estos pasos en detalle.

Paso 1: Declarar un efecto
Para declarar un efecto en el componente, importe el gancho useEffect desde React:

import { useEffect } from 'react';

Luego, llámalo al nivel superior de tu componente y pon un poco de código dentro de tu Efecto:

function MyComponent() {
  useEffect(() => {
        // El código se ejecutará después de *cada* renderización
  });
  return <div />;
}

Cada vez que su componente se renderice, React actualizará la pantalla y luego ejecutará el código dentro de useEffect. En otras palabras, useEffect "retrasa" la ejecución de un fragmento de código hasta que ese renderizado se refleja en la pantalla.

Veamos cómo puedes usar un efecto para sincronizar con un sistema externo. Considere un componente <VideoPlayer> React. Sería bueno controlar si está reproduciéndose o en pausa pasándole un accesorio isPlaying:

<VideoPlayer isPlaying={isPlaying} />;

El componente VideoPlayer personalizado representa la etiqueta integrada <video>:

function VideoPlayer({ src, isPlaying }) {
   // TODO: hacer algo con isPlaying
  return <video src={src} />;
}

Sin embargo, la etiqueta <video> del navegador no tiene un accesorio isPlaying. La única forma de controlarlo es llamar manualmente a los métodos play() y pause() en el elemento DOM.play() Debe sincronizar el valor de isPlaying prop, que indica si el video debe estar reproduciéndose actualmente, con llamadas imperativas como play() y pause().play()

Primero tendremos que obtener una referencia al nodo DOM <video>.

Es posible que tenga la tentación de intentar llamar a play()() o pause() durante la representación, pero eso no es correcto:

...

La razón por la que este código no es correcto es que intenta hacer algo con el nodo DOM durante la representación. En React, la representación debe ser un cálculo puro de JSX y no debe contener efectos secundarios como modificar el DOM.

Además, cuando VideoPlayer se llama por primera vez, ¡su DOM aún no existe! Todavía no hay un nodo DOM para llamar a play(play() o pause() porque React no sabe qué DOM crear hasta después de devolver el JSX.

La solución aquí es envolver el efecto secundario con useEffect para sacarlo del cálculo de renderizado:

...

Al envolver la actualización DOM en un efecto, deja que React actualice la pantalla primero. Entonces se ejecuta tu efecto.

Cuando el componente VideoPlayer se procese (ya sea la primera vez o si se vuelve a procesar), sucederán algunas cosas. Primero, React actualizará la pantalla, asegurando que la etiqueta <video> esté en el DOM con los accesorios correctos. Entonces React ejecutará su efecto. Finalmente, su efecto llamará a play()() o pause() dependiendo del valor de isPlaying prop.

Pulse Reproducir/Pausa varias veces y vea cómo el reproductor de vídeo permanece sincronizado con el valor isPlaying.

...

En este ejemplo, el "sistema externo" que sincronizó con el estado de React fue la API de medios del navegador. Puede utilizar un enfoque similar para envolver código heredado que no sea de React (como complementos jQuery) en componentes declarativos de React.

Tenga en cuenta que controlar un reproductor de video es mucho más complejo en la práctica. Al llamar a play() puede fallar, el usuario puede reproducir o pausar usando los controles integrados del navegador, y así sucesivamente. Este ejemplo es muy simplificado e incompleto.

Atención
De forma predeterminada, los efectos se ejecutan después de cada procesamiento. Esta es la razón por la cual un código como este producirá un bucle infinito:

const [count, setCount] = useState(0);
useEffect(() => {
  setCount(count + 1);
});

Los efectos se ejecutan como resultado de la representación. La configuración del estado desencadena la representación. Establecer el estado inmediatamente en un efecto es como enchufar una toma de corriente en sí mismo. El efecto se ejecuta, establece el estado, lo que provoca un reprocesamiento, lo que hace que se ejecute el efecto, establece el estado nuevamente, esto causa otro reprocesamiento, y así sucesivamente.

Los efectos generalmente deben sincronizar sus componentes con un sistema externo. Si no hay ningún sistema externo y solo desea ajustar algún estado en función de otro estado, es posible que no necesite un efecto.

Paso 2: Especificar las dependencias de efectos
De forma predeterminada, los efectos se ejecutan después de cada procesamiento. A menudo, esto no es lo que quieres:

    --A veces, es lento. La sincronización con un sistema externo no siempre es instantánea, por lo que es posible que desee omitir hacerlo a menos que sea necesario. Por ejemplo, no desea volver a conectarse al servidor de chat en cada pulsación de tecla.

    --A veces, está mal. Por ejemplo, no desea activar una animación de fundido de componentes en cada pulsación de tecla. La animación solo debe reproducirse una vez cuando el componente aparece por primera vez.

Para demostrar el problema, aquí está el ejemplo anterior con algunas llamadas console.log y una entrada de texto que actualiza el estado del componente principal. Observe cómo la escritura hace que el efecto se vuelva a ejecutar:

...

Puede indicar a React que omita volver a ejecutar innecesariamente el efecto especificando una matriz de dependencias como segundo argumento para la llamada useEffect. Comience agregando una matriz [] vacía al ejemplo anterior:

...

Debería ver que dice al presionar el boton, no hace nada:

...

El problema es que al proporcionar un array vacío le esta diciendo a react que solo ejecute ese efecto en el primer renderizado pero no es lo que se desea, el código dentro de su efecto depende del accesorio isPlaying para decidir qué hacer, pero esta dependencia no se declaró explícitamente. Para solucionar este problema, agregue isPlaying a la matriz de dependencias:

...

Ahora se declaran todas las dependencias, por lo que no hay ningún error. Especificar [isPlaying] como la matriz de dependencias le indica a React que debe omitir volver a ejecutar su efecto si isPlaying es el mismo que durante el procesamiento anterior. Con este cambio, escribir en la entrada no hace que el efecto se vuelva a ejecutar, pero al presionar Reproducir/Pausa sí:

...

La matriz de dependencias puede contener varias dependencias. React solo omitirá volver a ejecutar el efecto si todas las dependencias que especifique tienen exactamente los mismos valores que tenían durante el renderizado anterior. React compara los valores de dependencia utilizando la comparación Object.is. Consulte la referencia de la API useEffect para obtener más detalles.

Tenga en cuenta que no puede "elegir" sus dependencias. Obtendrá un error de lint si las dependencias que especificó no coinciden con lo que React espera según el código dentro de su Effect. Esto ayuda a detectar muchos errores en su código. Si su Efecto usa algún valor pero no desea  volver a ejecutar el Efecto cuando cambie, deberá editar el código del Efecto para no "necesitar" esa dependencia.

Atención
Los comportamientos sin la matriz de dependencias y con una matriz de dependencias [] vacía son muy diferentes:

useEffect(() => {
  // Esto se ejecuta después de cada render
});

useEffect(() => {
   // Esto sólo se ejecuta al montar (cuando aparece el componente)
}, []);

useEffect(() => {
      // Esto se ejecuta en el montaje *y también* si a o b han cambiado desde el último renderizado
}, [a, b]);

Echaremos un vistazo de cerca a lo que significa "montar" en el siguiente paso.

Paso 3: Agregar limpieza si es necesario
Consideremos un ejemplo diferente. Está escribiendo un componente de ChatRoom de chat que debe conectarse al servidor de chat cuando aparece. Se le proporciona una API createConnection()() que devuelve un objeto con los métodos connect() y disconnect() ¿Cómo se mantiene el componente conectado mientras se muestra al usuario?

Comience escribiendo la lógica del efecto:

useEffect(() => {
  const connection = createConnection();
  connection.connect();
});

Sería lento conectarse al chat después de cada re-renderizado, por lo que agrega la matriz de dependencias:

useEffect(() => {
  const connection = createConnection();
  connection.connect();
}, []);

El código dentro del efecto no utiliza ningún props o estado, por lo que la matriz de dependencias es [] (vacía). Esto le dice a React que solo ejecute este código cuando el componente "se monta", es decir, aparece en la pantalla por primera vez.

Intentemos ejecutar este código:

...

Este efecto solo se ejecuta en el soporte, por lo que puede esperar "✅ Connecting..." se imprima una vez en la consola. Sin embargo, si revisa la consola, "✅ Connecting..." se imprime dos veces. ¿Por qué sucede?

Imagine que el componente ChatRoom es parte de una aplicación más grande con muchas pantallas diferentes. El usuario comienza su viaje en la página ChatRoom. El componente se monta y llama a connection.connect() Luego imagine que el usuario navega a otra pantalla, por ejemplo, a la página Configuración. El componente ChatRoom se desmonta. Finalmente, el usuario hace clic en ChatRoom se monta nuevamente. Esto establecería una segunda conexión, ¡pero la primera conexión nunca se destruyó! A medida que el usuario navega por la aplicación, las conexiones seguirían acumulándose.

Errores como este son fáciles de pasar por alto sin pruebas manuales exhaustivas. Para ayudarlo a detectarlos rápidamente, en desarrollo React vuelve a montar cada componente una vez inmediatamente después de su montaje inicial. Ver el registro "✅ Connecting..." dos veces le ayuda a notar el problema real: su código no cierra la conexión cuando el componente se desmonta.

Para solucionar el problema, devuelve una función de limpieza de tu efecto:

  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, []);

React llamará a su función de limpieza cada vez antes de que el efecto se ejecute de nuevo, y una última vez cuando el componente se desmonte (se retire). Veamos qué sucede cuando se implementa la función de limpieza:

...

Ahora obtiene tres registros de consola en desarrollo:

"✅ Connecting..."
"❌ Disconnected."
"✅ Connecting..."

Este es el comportamiento correcto en el desarrollo. Al volver a montar su componente, React verifica que navegar de ida y vuelta no rompería su código. ¡Desconectarse y luego conectarse de nuevo es exactamente lo que debería suceder! Cuando implemente bien la limpieza, no debería haber ninguna diferencia visible para el usuario entre ejecutar el efecto una vez y ejecutarlo, limpiarlo y ejecutarlo nuevamente. Hay un par de llamadas de conexión / desconexión adicionales porque React está probando su código en busca de errores en el desarrollo. Esto es normal y no debes tratar de hacer que desaparezca.

En producción, solo verías "✅ Connecting..." vez. El remontaje de componentes solo ocurre en el desarrollo para ayudarlo a encontrar efectos que necesitan limpieza. Puede desactivar el modo estricto para inhabilitar el comportamiento de desarrollo, pero le recomendamos que lo mantenga activado. Esto te permite encontrar muchos errores como el anterior.

¿Cómo manejar el disparo del efecto dos veces en el desarrollo?
React vuelve a montar intencionalmente sus componentes en desarrollo para ayudarlo a encontrar errores como en el último ejemplo. La pregunta correcta no es "cómo ejecutar un efecto una vez", sino "cómo arreglar mi efecto para que funcione después de volver a montarlo".

Por lo general, la respuesta es implementar la función de limpieza. La función de limpieza debe detener o deshacer lo que sea que el efecto estaba haciendo. La regla general es que el usuario no debería poder distinguir entre el efecto que se ejecuta una vez (como en producción) y una secuencia de configuración → limpieza → configuración (como vería en desarrollo).

La mayoría de los efectos que escribirás encajarán en uno de los patrones comunes a continuación.

Control de widgets que no son de React
A veces es necesario agregar widgets de interfaz de usuario que no están escritos para React. Por ejemplo, supongamos que está agregando un componente de mapa a su página. Tiene un método setZoomLevel() y te gustaría mantener el nivel de zoom sincronizado con una variable zoomLevel en tu código React. Su efecto se vería similar a esto:

useEffect(() => {
  const map = mapRef.current;
  map.setZoomLevel(zoomLevel);
}, [zoomLevel]);

Tenga en cuenta que no hay limpieza necesaria en este caso. En desarrollo, React llamará al efecto dos veces, pero esto no es un problema porque llamar a setZoomLevel dos veces con el mismo valor no hace nada. Puede ser un poco más lento, pero esto no importa porque el remontaje es solo de desarrollo y no ocurrirá en producción.

Es posible que algunas API no le permitan llamarlas dos veces seguidas. Por ejemplo, el método showModal del elemento integrado <dialog> se produce si lo llama dos veces. Implemente la función de limpieza y haga que cierre el cuadro de diálogo:

useEffect(() => {
  const dialog = dialogRef.current;
  dialog.showModal();
  return () => dialog.close();
}, []);
En desarrollo, su efecto llamará a showModal(), luego close() inmediatamente() y luego showModal() nuevamente.showModal() Esto tiene el mismo comportamiento visible para el usuario que llamar a showModal() una vez, como vería en producción.

Suscribirse a eventos
Si su efecto se suscribe a algo, la función de limpieza debería cancelar la suscripción:

useEffect(() => {
  function handleScroll(e) {
    console.log(e.clientX, e.clientY);
  }
  window.addEventListener('scroll', handleScroll);
  return () => window.removeEventListener('scroll', handleScroll);
}, []);

En desarrollo, el efecto llamará a addEventListener(), luego inmediatamente removeEventListener() y, a continuación, addEventListener()removeEventListener() de nuevo con el mismo controlador.addEventListener() Por lo tanto, solo habría una suscripción activa a la vez. Esto tiene el mismo comportamiento visible para el usuario que llamar a addEventListener() una vez, como vería en producción.

Animación de activación
Si el efecto anima algo, la función de limpieza debe restablecer la animación a los valores iniciales:

useEffect(() => {
  const node = ref.current;
  node.style.opacity = 1; // Trigger the animation
  return () => {
    node.style.opacity = 0; // Reset to the initial value
  };
}, []);

En desarrollo, la opacidad se establecerá en 1, luego en 0 y luego en 1 nuevamente.1 Esto debería tener el mismo comportamiento visible para el usuario que configurarlo en 1 directamente, que es lo que sucedería en producción. Si utiliza una biblioteca de animaciones de terceros compatible con interpolación, la función de limpieza debería restablecer la línea de tiempo de la interpolación a su estado inicial.