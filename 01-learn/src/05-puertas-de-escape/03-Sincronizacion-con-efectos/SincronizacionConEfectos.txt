Sincronizaci√≥n con efectos
Algunos componentes necesitan sincronizarse con sistemas externos. Por ejemplo, es posible que desee controlar un componente que no sea de React en funci√≥n del estado React, configurar una conexi√≥n de servidor o enviar un registro de an√°lisis cuando aparezca un componente en la pantalla. Los efectos le permiten ejecutar c√≥digo despu√©s de la representaci√≥n para que pueda sincronizar su componente con alg√∫n sistema fuera de React.

Aprender√°s
¬øQu√© efectos son?
En qu√© se diferencian los efectos de los eventos
C√≥mo declarar un efecto en el componente
C√≥mo omitir volver a ejecutar un efecto innecesariamente
Por qu√© los efectos se ejecutan dos veces en desarrollo y c√≥mo solucionarlos

¬øQu√© son los efectos y en qu√© se diferencian de los eventos?
Antes de llegar a Effects, debe estar familiarizado con dos tipos de l√≥gica dentro de los componentes de React:

El c√≥digo de representaci√≥n (introducido en Descripci√≥n de la interfaz de usuario) reside en el nivel superior del componente. Aqu√≠ es donde tomas los accesorios y el estado, los transformas y devuelves el JSX que deseas ver en la pantalla. El c√≥digo de representaci√≥n debe ser puro. Al igual que una f√≥rmula matem√°tica, solo debe calcular el resultado, pero no hacer nada m√°s.

Los controladores de eventos (introducidos en Agregar interactividad) son funciones anidadas dentro de los componentes que hacen cosas en lugar de simplemente calcularlas. Un controlador de eventos puede actualizar un campo de entrada, enviar una solicitud HTTP POST para comprar un producto o llevar al usuario a otra pantalla. Los controladores de eventos contienen "efectos secundarios" (cambian el estado del programa) y son causados por una acci√≥n espec√≠fica del usuario (por ejemplo, un clic en el bot√≥n o escribir).

A veces esto no es suficiente. Considere un componente de sal√≥n de chat que debe conectarse al servidor ChatRoom siempre que est√© visible en la pantalla. Conectarse a un servidor no es un c√°lculo puro (es un efecto secundario), por lo que no puede ocurrir durante el renderizado. Sin embargo, no hay un solo evento en particular, como un clic, que haga que se muestre ChatRoom.

Los efectos permiten especificar los efectos secundarios causados por la representaci√≥n en s√≠, en lugar de por un evento determinado. Enviar un mensaje en el chat es un evento porque es causado directamente por el usuario haciendo clic en un bot√≥n espec√≠fico. Sin embargo, la configuraci√≥n de una conexi√≥n de servidor es un efecto porque debe ocurrir independientemente de qu√© interacci√≥n haya provocado la aparici√≥n del componente. Los efectos se ejecutan al final del proceso de renderizado despu√©s de que se actualice la pantalla. Este es un buen momento para sincronizar los componentes de React con alg√∫n sistema externo (como una red o una biblioteca de terceros).

Nota
Aqu√≠ y m√°s adelante en este texto, "Efecto" en may√∫scula se refiere a la definici√≥n espec√≠fica de React anterior, es decir, un efecto secundario causado por la representaci√≥n. Para referirnos al concepto de programaci√≥n m√°s amplio, diremos "efecto secundario".

Es posible que no necesites un efecto
No se apresure a agregar efectos a sus componentes. Tenga en cuenta que los efectos generalmente se usan para "salir" de su c√≥digo de React y sincronizarse con alg√∫n sistema externo. Esto incluye API de navegador, widgets de terceros, red, etc. Si su Efecto solo ajusta alg√∫n estado en funci√≥n de otro estado, es posible que no necesite un Efecto.

C√≥mo escribir un efecto
Para escribir un efecto, siga estos tres pasos:

1 .Declarar un efecto. De forma predeterminada, el efecto se ejecutar√° despu√©s de cada renderizado.

2. Especifique las dependencias de efecto. La mayor√≠a de los efectos solo deben volver a ejecutarse cuando sea necesario en lugar de despu√©s de cada renderizado. Por ejemplo, una animaci√≥n de fundido solo debe activarse cuando aparece un componente. La conexi√≥n y desconexi√≥n a un sal√≥n de chat solo debe ocurrir cuando el componente aparece y desaparece, o cuando cambia el sal√≥n de chat. Aprender√° a controlar esto especificando dependencias.

3. Agregue limpieza si es necesario. Algunos efectos necesitan especificar c√≥mo detener, deshacer o limpiar lo que estaban haciendo. Por ejemplo, "conectar" necesita "desconectar", "suscribirse" necesita "cancelar suscripci√≥n" y "buscar" necesita "cancelar" o "ignorar". Aprender√° c√≥mo hacerlo devolviendo una funci√≥n de limpieza.

Veamos cada uno de estos pasos en detalle.

Paso 1: Declarar un efecto
Para declarar un efecto en el componente, importe el gancho useEffect desde React:

import { useEffect } from 'react';

Luego, ll√°malo al nivel superior de tu componente y pon un poco de c√≥digo dentro de tu Efecto:

function MyComponent() {
  useEffect(() => {
        // El c√≥digo se ejecutar√° despu√©s de *cada* renderizaci√≥n
  });
  return <div />;
}

Cada vez que su componente se renderice, React actualizar√° la pantalla y luego ejecutar√° el c√≥digo dentro de useEffect. En otras palabras, useEffect "retrasa" la ejecuci√≥n de un fragmento de c√≥digo hasta que ese renderizado se refleja en la pantalla.

Veamos c√≥mo puedes usar un efecto para sincronizar con un sistema externo. Considere un componente <VideoPlayer> React. Ser√≠a bueno controlar si est√° reproduci√©ndose o en pausa pas√°ndole un accesorio isPlaying:

<VideoPlayer isPlaying={isPlaying} />;

El componente VideoPlayer personalizado representa la etiqueta integrada <video>:

function VideoPlayer({ src, isPlaying }) {
   // TODO: hacer algo con isPlaying
  return <video src={src} />;
}

Sin embargo, la etiqueta <video> del navegador no tiene un accesorio isPlaying. La √∫nica forma de controlarlo es llamar manualmente a los m√©todos play() y pause() en el elemento DOM.play() Debe sincronizar el valor de isPlaying prop, que indica si el video debe estar reproduci√©ndose actualmente, con llamadas imperativas como play() y pause().play()

Primero tendremos que obtener una referencia al nodo DOM <video>.

Es posible que tenga la tentaci√≥n de intentar llamar a play()() o pause() durante la representaci√≥n, pero eso no es correcto:

...

La raz√≥n por la que este c√≥digo no es correcto es que intenta hacer algo con el nodo DOM durante la representaci√≥n. En React, la representaci√≥n debe ser un c√°lculo puro de JSX y no debe contener efectos secundarios como modificar el DOM.

Adem√°s, cuando VideoPlayer se llama por primera vez, ¬°su DOM a√∫n no existe! Todav√≠a no hay un nodo DOM para llamar a play(play() o pause() porque React no sabe qu√© DOM crear hasta despu√©s de devolver el JSX.

La soluci√≥n aqu√≠ es envolver el efecto secundario con useEffect para sacarlo del c√°lculo de renderizado:

...

Al envolver la actualizaci√≥n DOM en un efecto, deja que React actualice la pantalla primero. Entonces se ejecuta tu efecto.

Cuando el componente VideoPlayer se procese (ya sea la primera vez o si se vuelve a procesar), suceder√°n algunas cosas. Primero, React actualizar√° la pantalla, asegurando que la etiqueta <video> est√© en el DOM con los accesorios correctos. Entonces React ejecutar√° su efecto. Finalmente, su efecto llamar√° a play()() o pause() dependiendo del valor de isPlaying prop.

Pulse Reproducir/Pausa varias veces y vea c√≥mo el reproductor de v√≠deo permanece sincronizado con el valor isPlaying.

...

En este ejemplo, el "sistema externo" que sincroniz√≥ con el estado de React fue la API de medios del navegador. Puede utilizar un enfoque similar para envolver c√≥digo heredado que no sea de React (como complementos jQuery) en componentes declarativos de React.

Tenga en cuenta que controlar un reproductor de video es mucho m√°s complejo en la pr√°ctica. Al llamar a play() puede fallar, el usuario puede reproducir o pausar usando los controles integrados del navegador, y as√≠ sucesivamente. Este ejemplo es muy simplificado e incompleto.

Atenci√≥n
De forma predeterminada, los efectos se ejecutan despu√©s de cada procesamiento. Esta es la raz√≥n por la cual un c√≥digo como este producir√° un bucle infinito:

const [count, setCount] = useState(0);
useEffect(() => {
  setCount(count + 1);
});

Los efectos se ejecutan como resultado de la representaci√≥n. La configuraci√≥n del estado desencadena la representaci√≥n. Establecer el estado inmediatamente en un efecto es como enchufar una toma de corriente en s√≠ mismo. El efecto se ejecuta, establece el estado, lo que provoca un reprocesamiento, lo que hace que se ejecute el efecto, establece el estado nuevamente, esto causa otro reprocesamiento, y as√≠ sucesivamente.

Los efectos generalmente deben sincronizar sus componentes con un sistema externo. Si no hay ning√∫n sistema externo y solo desea ajustar alg√∫n estado en funci√≥n de otro estado, es posible que no necesite un efecto.

Paso 2: Especificar las dependencias de efectos
De forma predeterminada, los efectos se ejecutan despu√©s de cada procesamiento. A menudo, esto no es lo que quieres:

    --A veces, es lento. La sincronizaci√≥n con un sistema externo no siempre es instant√°nea, por lo que es posible que desee omitir hacerlo a menos que sea necesario. Por ejemplo, no desea volver a conectarse al servidor de chat en cada pulsaci√≥n de tecla.

    --A veces, est√° mal. Por ejemplo, no desea activar una animaci√≥n de fundido de componentes en cada pulsaci√≥n de tecla. La animaci√≥n solo debe reproducirse una vez cuando el componente aparece por primera vez.

Para demostrar el problema, aqu√≠ est√° el ejemplo anterior con algunas llamadas console.log y una entrada de texto que actualiza el estado del componente principal. Observe c√≥mo la escritura hace que el efecto se vuelva a ejecutar:

...

Puede indicar a React que omita volver a ejecutar innecesariamente el efecto especificando una matriz de dependencias como segundo argumento para la llamada useEffect. Comience agregando una matriz [] vac√≠a al ejemplo anterior:

...

Deber√≠a ver que dice al presionar el boton, no hace nada:

...

El problema es que al proporcionar un array vac√≠o le esta diciendo a react que solo ejecute ese efecto en el primer renderizado pero no es lo que se desea, el c√≥digo dentro de su efecto depende del accesorio isPlaying para decidir qu√© hacer, pero esta dependencia no se declar√≥ expl√≠citamente. Para solucionar este problema, agregue isPlaying a la matriz de dependencias:

...

Ahora se declaran todas las dependencias, por lo que no hay ning√∫n error. Especificar [isPlaying] como la matriz de dependencias le indica a React que debe omitir volver a ejecutar su efecto si isPlaying es el mismo que durante el procesamiento anterior. Con este cambio, escribir en la entrada no hace que el efecto se vuelva a ejecutar, pero al presionar Reproducir/Pausa s√≠:

...

La matriz de dependencias puede contener varias dependencias. React solo omitir√° volver a ejecutar el efecto si todas las dependencias que especifique tienen exactamente los mismos valores que ten√≠an durante el renderizado anterior. React compara los valores de dependencia utilizando la comparaci√≥n Object.is. Consulte la referencia de la API useEffect para obtener m√°s detalles.

Tenga en cuenta que no puede "elegir" sus dependencias. Obtendr√° un error de lint si las dependencias que especific√≥ no coinciden con lo que React espera seg√∫n el c√≥digo dentro de su Effect. Esto ayuda a detectar muchos errores en su c√≥digo. Si su Efecto usa alg√∫n valor pero no desea  volver a ejecutar el Efecto cuando cambie, deber√° editar el c√≥digo del Efecto para no "necesitar" esa dependencia.

Atenci√≥n
Los comportamientos sin la matriz de dependencias y con una matriz de dependencias [] vac√≠a son muy diferentes:

useEffect(() => {
  // Esto se ejecuta despu√©s de cada render
});

useEffect(() => {
   // Esto s√≥lo se ejecuta al montar (cuando aparece el componente)
}, []);

useEffect(() => {
      // Esto se ejecuta en el montaje *y tambi√©n* si a o b han cambiado desde el √∫ltimo renderizado
}, [a, b]);

Echaremos un vistazo de cerca a lo que significa "montar" en el siguiente paso.

Paso 3: Agregar limpieza si es necesario
Consideremos un ejemplo diferente. Est√° escribiendo un componente de ChatRoom de chat que debe conectarse al servidor de chat cuando aparece. Se le proporciona una API createConnection()() que devuelve un objeto con los m√©todos connect() y disconnect() ¬øC√≥mo se mantiene el componente conectado mientras se muestra al usuario?

Comience escribiendo la l√≥gica del efecto:

useEffect(() => {
  const connection = createConnection();
  connection.connect();
});

Ser√≠a lento conectarse al chat despu√©s de cada re-renderizado, por lo que agrega la matriz de dependencias:

useEffect(() => {
  const connection = createConnection();
  connection.connect();
}, []);

El c√≥digo dentro del efecto no utiliza ning√∫n props o estado, por lo que la matriz de dependencias es [] (vac√≠a). Esto le dice a React que solo ejecute este c√≥digo cuando el componente "se monta", es decir, aparece en la pantalla por primera vez.

Intentemos ejecutar este c√≥digo:

...

Este efecto solo se ejecuta en el soporte, por lo que puede esperar "‚úÖ Connecting..." se imprima una vez en la consola. Sin embargo, si revisa la consola, "‚úÖ Connecting..." se imprime dos veces. ¬øPor qu√© sucede?

Imagine que el componente ChatRoom es parte de una aplicaci√≥n m√°s grande con muchas pantallas diferentes. El usuario comienza su viaje en la p√°gina ChatRoom. El componente se monta y llama a connection.connect() Luego imagine que el usuario navega a otra pantalla, por ejemplo, a la p√°gina Configuraci√≥n. El componente ChatRoom se desmonta. Finalmente, el usuario hace clic en ChatRoom se monta nuevamente. Esto establecer√≠a una segunda conexi√≥n, ¬°pero la primera conexi√≥n nunca se destruy√≥! A medida que el usuario navega por la aplicaci√≥n, las conexiones seguir√≠an acumul√°ndose.

Errores como este son f√°ciles de pasar por alto sin pruebas manuales exhaustivas. Para ayudarlo a detectarlos r√°pidamente, en desarrollo React vuelve a montar cada componente una vez inmediatamente despu√©s de su montaje inicial. Ver el registro "‚úÖ Connecting..." dos veces le ayuda a notar el problema real: su c√≥digo no cierra la conexi√≥n cuando el componente se desmonta.

Para solucionar el problema, devuelve una funci√≥n de limpieza de tu efecto:

  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, []);

React llamar√° a su funci√≥n de limpieza cada vez antes de que el efecto se ejecute de nuevo, y una √∫ltima vez cuando el componente se desmonte (se retire). Veamos qu√© sucede cuando se implementa la funci√≥n de limpieza:

...

Ahora obtiene tres registros de consola en desarrollo:

"‚úÖ Connecting..."
"‚ùå Disconnected."
"‚úÖ Connecting..."

Este es el comportamiento correcto en el desarrollo. Al volver a montar su componente, React verifica que navegar de ida y vuelta no romper√≠a su c√≥digo. ¬°Desconectarse y luego conectarse de nuevo es exactamente lo que deber√≠a suceder! Cuando implemente bien la limpieza, no deber√≠a haber ninguna diferencia visible para el usuario entre ejecutar el efecto una vez y ejecutarlo, limpiarlo y ejecutarlo nuevamente. Hay un par de llamadas de conexi√≥n / desconexi√≥n adicionales porque React est√° probando su c√≥digo en busca de errores en el desarrollo. Esto es normal y no debes tratar de hacer que desaparezca.

En producci√≥n, solo ver√≠as "‚úÖ Connecting..." vez. El remontaje de componentes solo ocurre en el desarrollo para ayudarlo a encontrar efectos que necesitan limpieza. Puede desactivar el modo estricto para inhabilitar el comportamiento de desarrollo, pero le recomendamos que lo mantenga activado. Esto te permite encontrar muchos errores como el anterior.

¬øC√≥mo manejar el disparo del efecto dos veces en el desarrollo?
React vuelve a montar intencionalmente sus componentes en desarrollo para ayudarlo a encontrar errores como en el √∫ltimo ejemplo. La pregunta correcta no es "c√≥mo ejecutar un efecto una vez", sino "c√≥mo arreglar mi efecto para que funcione despu√©s de volver a montarlo".

Por lo general, la respuesta es implementar la funci√≥n de limpieza. La funci√≥n de limpieza debe detener o deshacer lo que sea que el efecto estaba haciendo. La regla general es que el usuario no deber√≠a poder distinguir entre el efecto que se ejecuta una vez (como en producci√≥n) y una secuencia de configuraci√≥n ‚Üí limpieza ‚Üí configuraci√≥n (como ver√≠a en desarrollo).

La mayor√≠a de los efectos que escribir√°s encajar√°n en uno de los patrones comunes a continuaci√≥n.

Control de widgets que no son de React
A veces es necesario agregar widgets de interfaz de usuario que no est√°n escritos para React. Por ejemplo, supongamos que est√° agregando un componente de mapa a su p√°gina. Tiene un m√©todo setZoomLevel() y te gustar√≠a mantener el nivel de zoom sincronizado con una variable zoomLevel en tu c√≥digo React. Su efecto se ver√≠a similar a esto:

useEffect(() => {
  const map = mapRef.current;
  map.setZoomLevel(zoomLevel);
}, [zoomLevel]);

Tenga en cuenta que no hay limpieza necesaria en este caso. En desarrollo, React llamar√° al efecto dos veces, pero esto no es un problema porque llamar a setZoomLevel dos veces con el mismo valor no hace nada. Puede ser un poco m√°s lento, pero esto no importa porque el remontaje es solo de desarrollo y no ocurrir√° en producci√≥n.

Es posible que algunas API no le permitan llamarlas dos veces seguidas. Por ejemplo, el m√©todo showModal del elemento integrado <dialog> se produce si lo llama dos veces. Implemente la funci√≥n de limpieza y haga que cierre el cuadro de di√°logo:

useEffect(() => {
  const dialog = dialogRef.current;
  dialog.showModal();
  return () => dialog.close();
}, []);
En desarrollo, su efecto llamar√° a showModal(), luego close() inmediatamente() y luego showModal() nuevamente.showModal() Esto tiene el mismo comportamiento visible para el usuario que llamar a showModal() una vez, como ver√≠a en producci√≥n.

Suscribirse a eventos
Si su efecto se suscribe a algo, la funci√≥n de limpieza deber√≠a cancelar la suscripci√≥n:

useEffect(() => {
  function handleScroll(e) {
    console.log(e.clientX, e.clientY);
  }
  window.addEventListener('scroll', handleScroll);
  return () => window.removeEventListener('scroll', handleScroll);
}, []);

En desarrollo, el efecto llamar√° a addEventListener(), luego inmediatamente removeEventListener() y, a continuaci√≥n, addEventListener()removeEventListener() de nuevo con el mismo controlador.addEventListener() Por lo tanto, solo habr√≠a una suscripci√≥n activa a la vez. Esto tiene el mismo comportamiento visible para el usuario que llamar a addEventListener() una vez, como ver√≠a en producci√≥n.

Animaci√≥n de activaci√≥n
Si el efecto anima algo, la funci√≥n de limpieza debe restablecer la animaci√≥n a los valores iniciales:

useEffect(() => {
  const node = ref.current;
  node.style.opacity = 1; // Trigger the animation
  return () => {
    node.style.opacity = 0; // Reset to the initial value
  };
}, []);

En desarrollo, la opacidad se establecer√° en 1, luego en 0 y luego en 1 nuevamente.1 Esto deber√≠a tener el mismo comportamiento visible para el usuario que configurarlo en 1 directamente, que es lo que suceder√≠a en producci√≥n. Si utiliza una biblioteca de animaciones de terceros compatible con interpolaci√≥n, la funci√≥n de limpieza deber√≠a restablecer la l√≠nea de tiempo de la interpolaci√≥n a su estado inicial.

Obtenci√≥n de datos
Si el efecto obtiene algo, la funci√≥n de limpieza debe anular la recuperaci√≥n o ignorar su resultado:

useEffect(() => {
  let ignore = false;

  async function startFetching() {
    const json = await fetchTodos(userId);
    if (!ignore) {
      setTodos(json);
    }
  }

  startFetching();

  return () => {
    ignore = true;
  };
}, [userId]);

No puede "deshacer" una solicitud de red que ya se produjo, pero su funci√≥n de limpieza debe garantizar que la recuperaci√≥n que ya no es relevante no siga afectando a su aplicaci√≥n. Por ejemplo, si el userId cambia de 'Alice' a 'Bob', la limpieza garantiza que la respuesta ''Alice'' se ignore incluso si llega despu√©s de ''Bob''Alice' 'Bob'.

En desarrollo, ver√° dos recuperaciones en la pesta√±a Red. No hay nada de malo en ello. Con el enfoque anterior, el primer efecto se limpiar√° inmediatamente para que su copia de la variable ignore se establezca en true. Entonces, aunque haya una solicitud adicional, no afectar√° el estado gracias a la verificaci√≥n if (!ignore)

En producci√≥n, solo habr√° una solicitud. Si la segunda solicitud en desarrollo le molesta, el mejor enfoque es usar una soluci√≥n que deduplique las solicitudes y almacene en cach√© sus respuestas entre los componentes:

function TodoList() {
  const todos = useSomeDataLibrary(`/api/user/${userId}/todos`);
  // ...

Esto no solo mejorar√° la experiencia de desarrollo, sino que tambi√©n har√° que su aplicaci√≥n se sienta m√°s r√°pida. Por ejemplo, el usuario que presione el bot√≥n Atr√°s no tendr√° que esperar a que algunos datos se carguen nuevamente porque se almacenar√°n en cach√©. Puede crear una cach√© de este tipo usted mismo o utilizar una de las muchas alternativas existentes a la obtenci√≥n manual en Effects.

Env√≠o de an√°lisis
Considere este c√≥digo que env√≠a un evento de an√°lisis en la visita a la p√°gina:

useEffect(() => {
  logVisit(url); // Sends a POST request
}, [url]);

En desarrollo, logVisit se llamar√° dos veces para cada URL, por lo que podr√≠a sentirse tentado a intentar evitarlo. Recomendamos mantener este c√≥digo como est√°. Al igual que con ejemplos anteriores, no hay diferencia de comportamiento visible para el usuario entre ejecutarlo una vez y ejecutarlo dos veces. Desde un punto de vista pr√°ctico, logVisit no deber√≠a hacer nada en el desarrollo porque no desea que los registros de las m√°quinas de desarrollo sesguen las m√©tricas de producci√≥n. Su componente se vuelve a montar cada vez que guarda su archivo, por lo que enviar√≠a visitas adicionales durante el desarrollo de todos modos.

En producci√≥n, no habr√° registros de visitas duplicados.

Para depurar los eventos de an√°lisis que est√° enviando, puede implementar su aplicaci√≥n en un entorno de ensayo (que se ejecuta en modo de producci√≥n) o inhabilitar temporalmente el modo estricto y sus comprobaciones de remontaje solo de desarrollo. Tambi√©n puede enviar an√°lisis desde los controladores de eventos de cambio de ruta en lugar de Effects. Para un an√°lisis a√∫n m√°s preciso, los observadores de intersecci√≥n pueden ayudar a rastrear qu√© componentes est√°n en la ventana gr√°fica y cu√°nto tiempo permanecen visibles.

No es un efecto: inicializaci√≥n de la aplicaci√≥n
Parte de la l√≥gica solo debe ejecutarse una vez cuando se inicia la aplicaci√≥n. Puedes ponerlo fuera de tus componentes:

if (typeof window !== 'undefined') { // Check if we're running in the browser.
  checkAuthToken();
  loadDataFromLocalStorage();
}

function App() {
  // ...
}
Esto garantiza que dicha l√≥gica solo se ejecute una vez despu√©s de que el navegador cargue la p√°gina.

No es un efecto: comprar un producto
A veces, incluso si escribe una funci√≥n de limpieza, no hay forma de evitar las consecuencias visibles para el usuario de ejecutar el efecto dos veces. Por ejemplo, tal vez su efecto env√≠a una solicitud POST como comprar un producto:

useEffect(() => {
  // üî¥ Wrong: This Effect fires twice in development, exposing a problem in the code.
  fetch('/api/buy', { method: 'POST' });
}, []);

No querr√°s comprar el producto dos veces. Sin embargo, esta es tambi√©n la raz√≥n por la que no debe poner esta l√≥gica en un efecto. ¬øQu√© sucede si el usuario va a otra p√°gina y luego presiona Atr√°s? Su efecto se ejecutar√≠a de nuevo. No desea comprar el producto cuando el usuario visita una p√°gina; desea comprarlo cuando el usuario haga clic en el bot√≥n Comprar.

La compra no es causada por el renderizado; Es causada por una interacci√≥n espec√≠fica. Solo se ejecuta una vez porque la interacci√≥n (un clic) ocurre una vez. Elimine el efecto y mueva su solicitud //api/buy al controlador de eventos del bot√≥n Comprar:

  function handleClick() {
    // ‚úÖ Buying is an event because it is caused by a particular interaction.
    fetch('/api/buy', { method: 'POST' });
  }

Esto ilustra que si el remontaje rompe la l√≥gica de la aplicaci√≥n, esto generalmente descubre errores existentes. Desde la perspectiva del usuario, visitar una p√°gina no deber√≠a ser diferente de visitarla, hacer clic en un v√≠nculo y, a continuaci√≥n, presionar Atr√°s. React verifica que sus componentes no rompan este principio al volver a montarlos una vez en desarrollo.

Poniendo todo junto
Este patio de recreo puede ayudarte a "tener una idea" de c√≥mo funcionan los efectos en la pr√°ctica.

En este ejemplo se utiliza setTimeout para programar un registro de consola con el texto de entrada para que aparezca tres segundos despu√©s de que se ejecute el efecto. La funci√≥n de limpieza cancela el tiempo de espera pendiente. Comience presionando "Montar el componente":

...

Ver√° tres registros al principio: Programar registro "a", Cancelar registro "Schedule "a" log" y Schedule "a" log nuevamente. Cancel "a" log Tres segundos m√°s tarde tambi√©n habr√° un registro que dice a. Como aprendi√≥ anteriormente en esta p√°gina, el par de programaci√≥n / cancelaci√≥n adicional se debe a que React vuelve a montar el componente una vez en desarrollo para verificar que haya implementado bien la limpieza.

Ahora edite la entrada para decir abc. Si lo hace lo suficientemente r√°pido, ver√° el registro Programar "ab" inmediatamente seguido de Cancelar registro "Cancel "ab" log" y Schedule "abc" logSchedule "ab" log React siempre limpia el efecto del renderizado anterior antes del efecto del siguiente renderizado. Esta es la raz√≥n por la que incluso si escribe en la entrada r√°pidamente, hay como m√°ximo un tiempo de espera programado a la vez. Edite la entrada varias veces y observe la consola para tener una idea de c√≥mo se limpian los efectos.

Escriba algo en la entrada y luego presione inmediatamente "Desmontar el componente". Observe c√≥mo el desmontaje limpia el efecto del √∫ltimo renderizado. En este ejemplo, borra el √∫ltimo tiempo de espera antes de que tenga la oportunidad de disparar.

Finalmente, edite el componente anterior y comente la funci√≥n de limpieza para que los tiempos de espera no se cancelen. Intenta escribir abcde r√°pido. ¬øQu√© esperas que suceda en tres segundos? ¬øLa console.log(text) dentro del tiempo de espera imprimir√° el texto m√°s reciente text y producir√° cinco registros abcde? ¬°Pru√©balo para comprobar tu intuici√≥n!

Tres segundos despu√©s, deber√≠a ver una secuencia de registros (a, ababc, abcd y abcde) en lugar de cinco registros abcde.abcde Cada efecto "captura" el valor de text de su representaci√≥n correspondiente. No importa que el estado del text haya cambiado: un efecto del renderizado con text = 'ab' 'ab' siempre ver√° ''ab'. En otras palabras, los efectos de cada renderizado est√°n aislados entre s√≠. Si tienes curiosidad por saber c√≥mo funciona esto, puedes leer sobre los cierres.

Recapitulaci√≥n
--A diferencia de los eventos, los efectos son causados por la representaci√≥n en s√≠ misma en lugar de una interacci√≥n particular.

--Los efectos le permiten sincronizar un componente con alg√∫n sistema externo (API de terceros, red, etc.).

--De forma predeterminada, los efectos se ejecutan despu√©s de cada procesamiento (incluido el inicial).

--React omitir√° el efecto si todas sus dependencias tienen los mismos valores que durante el √∫ltimo renderizado.

--No puedes "elegir" tus dependencias. Est√°n determinados por el c√≥digo dentro del efecto.

--Una matriz de dependencias vac√≠a ([]) corresponde al componente "montaje", es decir, que se agrega a la pantalla.

--Cuando el modo estricto est√° activado, React monta componentes dos veces (¬°solo en desarrollo!) para probar tus efectos.

--Si su efecto se rompe debido al remontaje, debe implementar una funci√≥n de limpieza.

--React llamar√° a su funci√≥n de limpieza antes de que el efecto se ejecute la pr√≥xima vez y durante el desmontaje.