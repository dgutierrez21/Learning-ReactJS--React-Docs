Eliminar dependencias de los Efectos
Cuando escribes un Efecto, el linter verificar√° que has incluido todos los valores reactivos (como las props y el estado) que tu Efecto lee en la lista de dependencias de tu Efecto. As√≠ se asegura que el Efecto se mantenga sincronizado con las √∫ltimas props y el √∫ltimo estado de tu componente. Dependencias innecesarias pueden ocasionar que tu Efecto se ejecute demasiadas veces, o incluso crear un ciclo infinito. Sigue esta gu√≠a para revisar y eliminar dependencias innecesarias de tus Efectos.

Aprender√°s
C√≥mo arreglar ciclos infinitos de dependencias de un Efecto
Qu√© hacer cuando quieres eliminar una dependencia
C√≥mo leer un valor en un Efecto sin ¬´reaccionar¬ª a √©l
C√≥mo y por qu√© evitar objectos y funciones como dependencias
Por qu√© suprimir la advertencia de la dependencia es peligroso, y qu√© hacer en su lugar

Las dependencias deben corresponderse con el c√≥digo
Cuando escribes un Efecto, primero debes especificar como iniciar y parar lo que sea que tu Efecto est√° haciendo.

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  	// ...
}

Entonces, si dejas la lista de dependencias del Efecto vac√≠a ([]), el linter sugerir√° las dependencias correctas:

...

Ll√©nalas de acuerdo a lo que dice el linter:

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ‚úÖ All dependencies declared
  // ...
}

Los Efectos ¬´reaccionar¬ª a valores reactivos. Dado que roomId es un valor reactivo (puede cambiar durante un rerenderizado), el linter verifica que lo has especificado como una dependencia. Si roomId recibe un valor diferente, React resincronizar√° tu Efecto. Esto asegura que el chat se mantiene conectado a la sala seleccionada y ¬´reacciona¬ª al dropdown:

Para eliminar una dependencia, prueba que no es una dependencia
Debes notar que no puedes ¬´escoger¬ª tus dependencias de tu Efecto. Cada valor reactivo que se usa en el c√≥digo de tu Efecto debe declararse en tu lista de dependencias. La lista de dependencias de tu Efecto est√° determinada por el c√≥digo a su alrededor:

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) { // Este es un valor reactivo
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // Este Efecto lee el valor reactivo
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ‚úÖ Por tanto debes especificar el valor reactivo como una dependencia de tu Efecto
  // ...
}

Los valores reactivos incluyen las props y todas las variables y funciones declaradas directamente dentro de componente. Dado que roomId es un valor reactivo, no puedes eliminarlo de la lista de dependencias. El linter no lo permitir√≠a:

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, []); // üî¥ React Hook useEffect has a missing dependency: 'roomId'
  // ...
}

¬°Y el linter estar√≠a en lo correcto! Dado que roomId puede cambiar con el tiempo, esto introducir√≠a un bug en tu c√≥digo.

Para eliminar una dependencias, necesitas ¬´probarle¬ª al linter que no necesita ser una dependencia. Por ejemplo, puedes mover roomId fuera de componente para probar que no es reactivo y no cambiar√° entre rerenderizados:

const serverUrl = 'https://localhost:1234';
const roomId = 'music'; // Ya no es un valor reactivo

function ChatRoom() {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, []); // ‚úÖ Se declararon todas las dependencias
  // ...
}

Ahora que roomId no es un valor reactivo (y no puede cambiar en un rerenderizado) no necesita estar como dependencia:

https://codesandbox.io/s/opk4l4?file=%2FApp.js&utm_medium=sandpack

Por esto es que ahora podemos especificar una lista de dependencias vac√≠a ([]). Tu Efecto realmente no depende y de ning√∫n valor reactivo, por lo que realmente no necesita volverse a ejecutar cuando cualquiera de las props o el estado del componente cambie.

Para cambiar las dependencias, cambia el c√≥digo
Puede que hayas notado un patr√≥n en tu flujo de trabajo:

    1. Primero, cambias el c√≥digo de tu Efecto o como se declaran los valores reactivos.
    2. Luego, sigues al linter y ajustas las dependencias para hacerlas corresponder con el c√≥digo que cambiaste.
    3. Si no est√°s a gusto con la lista de dependencias, puedes ir al primer paso (y cambiar el c√≥digo nuevamente).

La √∫ltima parte es importante. Si quieres cambiar las dependencias, cambia primero el c√≥digo que lo circunda. Puedes pensar en la lista de dependencia como una lista de todos los valores reactivos usado por el c√≥digo de tu Efecto. No eliges intencionalmente qu√© poner en esa lista. La lista describe tu c√≥digo. Para cambiar la lista de dependencia, cambia el c√≥digo.

Esto puede parecerse a resolver una ecuaci√≥n. Puedes iniciar con un objetivo (por ejemplo, eliminar una dependencia), y necesitas ¬´encontrar¬ª el c√≥digo exacto que logre ese objetivo. No todo el mundo encuentra divertido resolver ecuaciones ¬°y lo mismo podr√≠a decirse sobre escribir Efectos! Por suerte, debajo hay una lista de recetas comunes que puedes probar.

Atenci√≥n
Si tienes una base de c√≥digo existente, puede que tengas algunos Efectos que suprimen la advertencia de linter de esta forma:

useEffect(() => {
  // ...
  // üî¥ Evita suprimir as√≠ la advertencia del linter:
  // eslint-ignore-next-line react-hooks/exhaustive-dependencies
}, []);

Cuando las dependencias no se ajustan al c√≥digo, hay un riesgo muy alto de introducir bugs. Al suprimir el linter, le mientes a React sobre los valores de los que depende tu Efecto. En su lugar, usa las t√©cnicas que se muestran debajo.

Eliminar dependencias innecesarias
Cada vez que ajustas las dependencias del Efecto para reflejar el c√≥digo, mira a la lista de dependencias. ¬øTiene sentido volver a correr cuando alguna de estas dependencias cambie? A veces, la respuesta es ¬´no¬ª:

    --A veces, quieres volver a ejecutar diferentes partes de tu Efecto bajo condiciones diferentes.
    --A veces, quieres leer solo el √∫ltimo valor de alguna dependencia en lugar de ¬´reaccionar¬ª a sus cambios.
    --A veces, una dependencia puede cambiar muy a menudo de forma no intencional porque es un objeto o una funci√≥n.
    
Para encontrar la soluci√≥n correcta, necesitas responder algunas preguntas sobre tu Efecto. Revis√©moslas.

¬øDeber√≠a moverse este c√≥digo a un manejador de eventos?
Sobre lo primero que debes pensar es si este c√≥digo deber√≠a ser un Efecto.

Imagina un formulario. Al enviarse, actualizas la variable de estado submitted a true. Necesitas enviar una petici√≥n POST y mostrar una notificaci√≥n. Has decidido ubicar esta l√≥digo dentro de un Efecto que ¬´reacciona¬ª al cambio de submitted a true:

function Form() {
  const [submitted, setSubmitted] = useState(false);

  useEffect(() => {
    if (submitted) {
      // üî¥ Evita: L√≥gica espec√≠fica de Evento dentro de un Efecto
      post('/api/register');
      showNotification('Successfully registered!');
    }
  }, [submitted]);

  function handleSubmit() {
    setSubmitted(true);
  }

  // ...
}

Despu√©s, quieres estilizar el mensaje de notificaci√≥n de acuerdo al tema actual, as√≠ que lees el tema actual. Dado que theme se declara en el cuerpo del componente, es un valor reactivo, y debes declararlo como una dependencia:

function Form() {
  const [submitted, setSubmitted] = useState(false);
  const theme = useContext(ThemeContext);

  useEffect(() => {
    if (submitted) {
      // üî¥ Evita: L√≥gica espec√≠fica de Evento dentro de un Efecto
      post('/api/register');
      showNotification('Successfully registered!', theme);
    }
  }, [submitted, theme]); // ‚úÖ Todas las dependencias declaradas

  function handleSubmit() {
    setSubmitted(true);
  }  

  // ...
}

Pero al hacer esto, has introducido un bug. Imagina que env√≠as un formulario primero y luego cambias entre temas oscuros y claros. La variable theme cambiar√°, el Efecto se volver√° a ejecutar, ¬°y por tanto mostrar√° la misma notificaci√≥n nuevamente!

El problema aqu√≠ es que no debi√≥ haber sido nunca un Efecto. Quieres enviar una petici√≥n POST y mostrar la notificaci√≥n en respuesta al env√≠o del formulario, que es una interacci√≥n particular. Cuando quieres ejecutar alg√∫n c√≥digo en respuesta a una interacci√≥n particular, pon esa l√≥gica directamente en el manejador de eventos correspondiente:

function Form() {
  const theme = useContext(ThemeContext);

  function handleSubmit() {
    // ‚úÖ Bien: L√≥gica espec√≠fica de Evento se llama desde manejadores de evento
    post('/api/register');
    showNotification('Successfully registered!', theme);
  }  

  // ...
}

Ahora que el c√≥digo est√° en un manejador de evento, no es reactivo ‚Äîpor lo que solo se ejecutar√° cuando el usuario env√≠a el formulario‚Äî. Lee m√°s acerca de escoger entre manejadores de eventos y Efectos ( https://cutt.ly/o3REIA5 ) y c√≥mo eliminar Efectos innecesarios ( https://cutt.ly/93REANl )

¬øT√∫ Efecto hace varias cosas no relacionadas?
La pr√≥xima preguntas que te debes hacer es si tu Efecto est√° haciendo varias cosas no relacionadas.

Imagina que est√°s creando un formulario de env√≠os en el que el usuario necesita elegir su ciudad y √°rea. Obtienes la lista de ciudades cities del servidor de acuerdo al pa√≠s seleccionado country de forma tal que los puedas mostrar como opciones en un dropdown:

function ShippingForm({ country }) {
  const [cities, setCities] = useState(null);
  const [city, setCity] = useState(null);

  useEffect(() => {
    let ignore = false;
    fetch(`/api/cities?country=${country}`)
      .then(response => response.json())
      .then(json => {
        if (!ignore) {
          setCities(json);
        }
      });
    return () => {
      ignore = true;
    };
  }, [country]); // ‚úÖ All dependencies declared

  // ...

Este es un buen ejemplo de obtener datos en un Efecto. Est√°s sincronizando el estado cities con la red de acuerdo a la prop country. No puedes hacer esto en un manejador de eventos porque necesitas obtener los datos tan pronto como se muestre ShippingForm y cada vez que cambie country (sin importar qu√© interacciones causa el cambio).

Digamos ahora que est√°s a√±adiendo una segunda caja de selecci√≥n para las areas de la ciudad, que deber√≠a obtener las areas para la ciudad city actualmente seleccionada. Podr√≠as comenzar a√±adiendo una segunda llamada fetch para la lista de areas dentro del mismo Efecto:

function ShippingForm({ country }) {
  const [cities, setCities] = useState(null);
  const [city, setCity] = useState(null);
  const [areas, setAreas] = useState(null);

  useEffect(() => {
    let ignore = false;
    fetch(`/api/cities?country=${country}`)
      .then(response => response.json())
      .then(json => {
        if (!ignore) {
          setCities(json);
        }
      });
    // üî¥ Avoid: A single Effect synchronizes two independent processes
    if (city) {
      fetch(`/api/areas?city=${city}`)
        .then(response => response.json())
        .then(json => {
          if (!ignore) {
            setAreas(json);
          }
        });
    }
    return () => {
      ignore = true;
    };
  }, [country, city]); // ‚úÖ All dependencies declared

  // ...

Sin embargo, como ahora el Efecto usa la variable de estado city, tienes que a√±adir city a la lista de dependencias. Resulta que esto introduce un problema. Ahora, cada vez que el usuario seleccionar una ciudad diferente, el Efecto volver√° a ejecutarse y llamar a fetchCities(country). Como resultado, obtendr√°s innecesariamente la lista de ciudades muchas veces.

El problema con este c√≥digo es que est√°s sincronizando dos cosas que no guardan relaci√≥n:

    1. Quieres sincronizar el estado cities con la red con base en la prop country.
    2. Quieres sincronizar el estado areas con la red con base en el estado city.

Divide la l√≥gica en dos Efectos y cada uno reaccionar√° a la variable que necesita para sincronizarse:

function ShippingForm({ country }) {
  const [cities, setCities] = useState(null);
  useEffect(() => {
    let ignore = false;
    fetch(`/api/cities?country=${country}`)
      .then(response => response.json())
      .then(json => {
        if (!ignore) {
          setCities(json);
        }
      });
    return () => {
      ignore = true;
    };
  }, [country]); // ‚úÖ All dependencies declared

  const [city, setCity] = useState(null);
  const [areas, setAreas] = useState(null);
  useEffect(() => {
    if (city) {
      let ignore = false;
      fetch(`/api/areas?city=${city}`)
        .then(response => response.json())
        .then(json => {
          if (!ignore) {
            setAreas(json);
          }
        });
      return () => {
        ignore = true;
      };
    }
  }, [city]); // ‚úÖ All dependencies declared

  // ...

Ahora el primer Efecto solo se vuelve a ejecutar si country cambia, mientras el segundo Efecto se vuelve a ejecutar cuando city cambia. Los has separado a prop√≥sito: dos cosas diferentes se sincronizan con dos Efectos separados. Dos Efectos separados tienen dos listas de dependencias separadas, por lo que ya no se activar√°n mutuamente sin quererlo.

El c√≥digo final no es m√°s largo que el original, pero separar estos Efectos a√∫n es correcto. Cada Efecto debe representar un proceso de sincronizaci√≥n independiente. En este ejemplo, eliminar un Efecto no rompe la l√≥gica del otro Efecto. Este es un buen indicador de que sincronizan cosas diferentes, y ten√≠a sentido separarlos. Si la duplicaci√≥n te preocupa, puedes mejorar este c√≥digo a√∫n m√°s extrayendo l√≥gica repetitiva en un Hook personalizado ( https://acortar.link/GGgZCA )

