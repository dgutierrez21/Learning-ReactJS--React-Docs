Eliminar dependencias de los Efectos
Cuando escribes un Efecto, el linter verificar√° que has incluido todos los valores reactivos (como las props y el estado) que tu Efecto lee en la lista de dependencias de tu Efecto. As√≠ se asegura que el Efecto se mantenga sincronizado con las √∫ltimas props y el √∫ltimo estado de tu componente. Dependencias innecesarias pueden ocasionar que tu Efecto se ejecute demasiadas veces, o incluso crear un ciclo infinito. Sigue esta gu√≠a para revisar y eliminar dependencias innecesarias de tus Efectos.

Aprender√°s
C√≥mo arreglar ciclos infinitos de dependencias de un Efecto
Qu√© hacer cuando quieres eliminar una dependencia
C√≥mo leer un valor en un Efecto sin ¬´reaccionar¬ª a √©l
C√≥mo y por qu√© evitar objectos y funciones como dependencias
Por qu√© suprimir la advertencia de la dependencia es peligroso, y qu√© hacer en su lugar

Las dependencias deben corresponderse con el c√≥digo
Cuando escribes un Efecto, primero debes especificar como iniciar y parar lo que sea que tu Efecto est√° haciendo.

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  	// ...
}

Entonces, si dejas la lista de dependencias del Efecto vac√≠a ([]), el linter sugerir√° las dependencias correctas:

...

Ll√©nalas de acuerdo a lo que dice el linter:

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ‚úÖ All dependencies declared
  // ...
}

Los Efectos ¬´reaccionar¬ª a valores reactivos. Dado que roomId es un valor reactivo (puede cambiar durante un rerenderizado), el linter verifica que lo has especificado como una dependencia. Si roomId recibe un valor diferente, React resincronizar√° tu Efecto. Esto asegura que el chat se mantiene conectado a la sala seleccionada y ¬´reacciona¬ª al dropdown:

Para eliminar una dependencia, prueba que no es una dependencia
Debes notar que no puedes ¬´escoger¬ª tus dependencias de tu Efecto. Cada valor reactivo que se usa en el c√≥digo de tu Efecto debe declararse en tu lista de dependencias. La lista de dependencias de tu Efecto est√° determinada por el c√≥digo a su alrededor:

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) { // Este es un valor reactivo
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // Este Efecto lee el valor reactivo
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ‚úÖ Por tanto debes especificar el valor reactivo como una dependencia de tu Efecto
  // ...
}

Los valores reactivos incluyen las props y todas las variables y funciones declaradas directamente dentro de componente. Dado que roomId es un valor reactivo, no puedes eliminarlo de la lista de dependencias. El linter no lo permitir√≠a:

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, []); // üî¥ React Hook useEffect has a missing dependency: 'roomId'
  // ...
}

¬°Y el linter estar√≠a en lo correcto! Dado que roomId puede cambiar con el tiempo, esto introducir√≠a un bug en tu c√≥digo.

Para eliminar una dependencias, necesitas ¬´probarle¬ª al linter que no necesita ser una dependencia. Por ejemplo, puedes mover roomId fuera de componente para probar que no es reactivo y no cambiar√° entre rerenderizados:

const serverUrl = 'https://localhost:1234';
const roomId = 'music'; // Ya no es un valor reactivo

function ChatRoom() {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, []); // ‚úÖ Se declararon todas las dependencias
  // ...
}

Ahora que roomId no es un valor reactivo (y no puede cambiar en un rerenderizado) no necesita estar como dependencia:

https://codesandbox.io/s/opk4l4?file=%2FApp.js&utm_medium=sandpack

Por esto es que ahora podemos especificar una lista de dependencias vac√≠a ([]). Tu Efecto realmente no depende y de ning√∫n valor reactivo, por lo que realmente no necesita volverse a ejecutar cuando cualquiera de las props o el estado del componente cambie.

Para cambiar las dependencias, cambia el c√≥digo
Puede que hayas notado un patr√≥n en tu flujo de trabajo:

    1. Primero, cambias el c√≥digo de tu Efecto o como se declaran los valores reactivos.
    2. Luego, sigues al linter y ajustas las dependencias para hacerlas corresponder con el c√≥digo que cambiaste.
    3. Si no est√°s a gusto con la lista de dependencias, puedes ir al primer paso (y cambiar el c√≥digo nuevamente).

La √∫ltima parte es importante. Si quieres cambiar las dependencias, cambia primero el c√≥digo que lo circunda. Puedes pensar en la lista de dependencia como una lista de todos los valores reactivos usado por el c√≥digo de tu Efecto. No eliges intencionalmente qu√© poner en esa lista. La lista describe tu c√≥digo. Para cambiar la lista de dependencia, cambia el c√≥digo.

Esto puede parecerse a resolver una ecuaci√≥n. Puedes iniciar con un objetivo (por ejemplo, eliminar una dependencia), y necesitas ¬´encontrar¬ª el c√≥digo exacto que logre ese objetivo. No todo el mundo encuentra divertido resolver ecuaciones ¬°y lo mismo podr√≠a decirse sobre escribir Efectos! Por suerte, debajo hay una lista de recetas comunes que puedes probar.

Atenci√≥n
Si tienes una base de c√≥digo existente, puede que tengas algunos Efectos que suprimen la advertencia de linter de esta forma:

useEffect(() => {
  // ...
  // üî¥ Evita suprimir as√≠ la advertencia del linter:
  // eslint-ignore-next-line react-hooks/exhaustive-dependencies
}, []);

Cuando las dependencias no se ajustan al c√≥digo, hay un riesgo muy alto de introducir bugs. Al suprimir el linter, le mientes a React sobre los valores de los que depende tu Efecto. En su lugar, usa las t√©cnicas que se muestran debajo.

Eliminar dependencias innecesarias
Cada vez que ajustas las dependencias del Efecto para reflejar el c√≥digo, mira a la lista de dependencias. ¬øTiene sentido volver a correr cuando alguna de estas dependencias cambie? A veces, la respuesta es ¬´no¬ª:

    --A veces, quieres volver a ejecutar diferentes partes de tu Efecto bajo condiciones diferentes.
    --A veces, quieres leer solo el √∫ltimo valor de alguna dependencia en lugar de ¬´reaccionar¬ª a sus cambios.
    --A veces, una dependencia puede cambiar muy a menudo de forma no intencional porque es un objeto o una funci√≥n.
    
Para encontrar la soluci√≥n correcta, necesitas responder algunas preguntas sobre tu Efecto. Revis√©moslas.

¬øDeber√≠a moverse este c√≥digo a un manejador de eventos?
Sobre lo primero que debes pensar es si este c√≥digo deber√≠a ser un Efecto.

Imagina un formulario. Al enviarse, actualizas la variable de estado submitted a true. Necesitas enviar una petici√≥n POST y mostrar una notificaci√≥n. Has decidido ubicar esta l√≥digo dentro de un Efecto que ¬´reacciona¬ª al cambio de submitted a true:

function Form() {
  const [submitted, setSubmitted] = useState(false);

  useEffect(() => {
    if (submitted) {
      // üî¥ Evita: L√≥gica espec√≠fica de Evento dentro de un Efecto
      post('/api/register');
      showNotification('Successfully registered!');
    }
  }, [submitted]);

  function handleSubmit() {
    setSubmitted(true);
  }

  // ...
}

Despu√©s, quieres estilizar el mensaje de notificaci√≥n de acuerdo al tema actual, as√≠ que lees el tema actual. Dado que theme se declara en el cuerpo del componente, es un valor reactivo, y debes declararlo como una dependencia:

function Form() {
  const [submitted, setSubmitted] = useState(false);
  const theme = useContext(ThemeContext);

  useEffect(() => {
    if (submitted) {
      // üî¥ Evita: L√≥gica espec√≠fica de Evento dentro de un Efecto
      post('/api/register');
      showNotification('Successfully registered!', theme);
    }
  }, [submitted, theme]); // ‚úÖ Todas las dependencias declaradas

  function handleSubmit() {
    setSubmitted(true);
  }  

  // ...
}

Pero al hacer esto, has introducido un bug. Imagina que env√≠as un formulario primero y luego cambias entre temas oscuros y claros. La variable theme cambiar√°, el Efecto se volver√° a ejecutar, ¬°y por tanto mostrar√° la misma notificaci√≥n nuevamente!

El problema aqu√≠ es que no debi√≥ haber sido nunca un Efecto. Quieres enviar una petici√≥n POST y mostrar la notificaci√≥n en respuesta al env√≠o del formulario, que es una interacci√≥n particular. Cuando quieres ejecutar alg√∫n c√≥digo en respuesta a una interacci√≥n particular, pon esa l√≥gica directamente en el manejador de eventos correspondiente:

function Form() {
  const theme = useContext(ThemeContext);

  function handleSubmit() {
    // ‚úÖ Bien: L√≥gica espec√≠fica de Evento se llama desde manejadores de evento
    post('/api/register');
    showNotification('Successfully registered!', theme);
  }  

  // ...
}

Ahora que el c√≥digo est√° en un manejador de evento, no es reactivo ‚Äîpor lo que solo se ejecutar√° cuando el usuario env√≠a el formulario‚Äî. Lee m√°s acerca de escoger entre manejadores de eventos y Efectos ( https://cutt.ly/o3REIA5 ) y c√≥mo eliminar Efectos innecesarios ( https://cutt.ly/93REANl )

¬øT√∫ Efecto hace varias cosas no relacionadas?
La pr√≥xima preguntas que te debes hacer es si tu Efecto est√° haciendo varias cosas no relacionadas.

Imagina que est√°s creando un formulario de env√≠os en el que el usuario necesita elegir su ciudad y √°rea. Obtienes la lista de ciudades cities del servidor de acuerdo al pa√≠s seleccionado country de forma tal que los puedas mostrar como opciones en un dropdown:

function ShippingForm({ country }) {
  const [cities, setCities] = useState(null);
  const [city, setCity] = useState(null);

  useEffect(() => {
    let ignore = false;
    fetch(`/api/cities?country=${country}`)
      .then(response => response.json())
      .then(json => {
        if (!ignore) {
          setCities(json);
        }
      });
    return () => {
      ignore = true;
    };
  }, [country]); // ‚úÖ All dependencies declared

  // ...

Este es un buen ejemplo de obtener datos en un Efecto. Est√°s sincronizando el estado cities con la red de acuerdo a la prop country. No puedes hacer esto en un manejador de eventos porque necesitas obtener los datos tan pronto como se muestre ShippingForm y cada vez que cambie country (sin importar qu√© interacciones causa el cambio).

Digamos ahora que est√°s a√±adiendo una segunda caja de selecci√≥n para las areas de la ciudad, que deber√≠a obtener las areas para la ciudad city actualmente seleccionada. Podr√≠as comenzar a√±adiendo una segunda llamada fetch para la lista de areas dentro del mismo Efecto:

function ShippingForm({ country }) {
  const [cities, setCities] = useState(null);
  const [city, setCity] = useState(null);
  const [areas, setAreas] = useState(null);

  useEffect(() => {
    let ignore = false;
    fetch(`/api/cities?country=${country}`)
      .then(response => response.json())
      .then(json => {
        if (!ignore) {
          setCities(json);
        }
      });
    // üî¥ Avoid: A single Effect synchronizes two independent processes
    if (city) {
      fetch(`/api/areas?city=${city}`)
        .then(response => response.json())
        .then(json => {
          if (!ignore) {
            setAreas(json);
          }
        });
    }
    return () => {
      ignore = true;
    };
  }, [country, city]); // ‚úÖ All dependencies declared

  // ...

Sin embargo, como ahora el Efecto usa la variable de estado city, tienes que a√±adir city a la lista de dependencias. Resulta que esto introduce un problema. Ahora, cada vez que el usuario seleccionar una ciudad diferente, el Efecto volver√° a ejecutarse y llamar a fetchCities(country). Como resultado, obtendr√°s innecesariamente la lista de ciudades muchas veces.

El problema con este c√≥digo es que est√°s sincronizando dos cosas que no guardan relaci√≥n:

    1. Quieres sincronizar el estado cities con la red con base en la prop country.
    2. Quieres sincronizar el estado areas con la red con base en el estado city.

Divide la l√≥gica en dos Efectos y cada uno reaccionar√° a la variable que necesita para sincronizarse:

function ShippingForm({ country }) {
  const [cities, setCities] = useState(null);
  useEffect(() => {
    let ignore = false;
    fetch(`/api/cities?country=${country}`)
      .then(response => response.json())
      .then(json => {
        if (!ignore) {
          setCities(json);
        }
      });
    return () => {
      ignore = true;
    };
  }, [country]); // ‚úÖ All dependencies declared

  const [city, setCity] = useState(null);
  const [areas, setAreas] = useState(null);
  useEffect(() => {
    if (city) {
      let ignore = false;
      fetch(`/api/areas?city=${city}`)
        .then(response => response.json())
        .then(json => {
          if (!ignore) {
            setAreas(json);
          }
        });
      return () => {
        ignore = true;
      };
    }
  }, [city]); // ‚úÖ All dependencies declared

  // ...

Ahora el primer Efecto solo se vuelve a ejecutar si country cambia, mientras el segundo Efecto se vuelve a ejecutar cuando city cambia. Los has separado a prop√≥sito: dos cosas diferentes se sincronizan con dos Efectos separados. Dos Efectos separados tienen dos listas de dependencias separadas, por lo que ya no se activar√°n mutuamente sin quererlo.

El c√≥digo final no es m√°s largo que el original, pero separar estos Efectos a√∫n es correcto. Cada Efecto debe representar un proceso de sincronizaci√≥n independiente. En este ejemplo, eliminar un Efecto no rompe la l√≥gica del otro Efecto. Este es un buen indicador de que sincronizan cosas diferentes, y ten√≠a sentido separarlos. Si la duplicaci√≥n te preocupa, puedes mejorar este c√≥digo a√∫n m√°s extrayendo l√≥gica repetitiva en un Hook personalizado ( https://acortar.link/GGgZCA )

¬øEst√°s leyendo alg√∫n estado para calcular el pr√≥ximo estado?
Este Efecto actualiza la variable de estado messages con un nuevo array creado cada vez que llega un nuevo mensaje:

function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      setMessages([...messages, receivedMessage]);
    });
    // ...

Usa la variable messages para crear un nuevo array que se inicia con todos los mensajes existentes y a√±ade el nuevo mensaje al final. Sin embargo, dado que messages es un valor reactivo que un Efecto lee, debe ser una dependencia:

function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      setMessages([...messages, receivedMessage]);
    });
    return () => connection.disconnect();
  }, [roomId, messages]); // ‚úÖ All dependencies declared
  // ...

Y cuando se incluye messages como dependencia se introduce un problema.

Cada vez que recibes un mensaje, setMessages() causa que el componente se vuelva a renderizar con un nuevo array messages que incluye el mensaje recibido. Sin embargo, dado que este Efecto ahora depende de messages, esto tambi√©n resincronizar√° el Efecto. Por tanto cada nuevo mensaje har√° que el chat se reconecte. ¬°El usuario no querr√≠a eso!

Para resolver el problema, no leas messages dentro del Efecto. En cambio, pasa una funci√≥n actualizadora a setMessages:

function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      setMessages(msgs => [...msgs, receivedMessage]);
    });
    return () => connection.disconnect();
  }, [roomId]); // ‚úÖ All dependencies declared
  // ...
  
Ten en cuenta que ahora el Efecto no lee para nada la variable messages. Solo necesitas pasar una funci√≥n actualizadora como msgs => [...msgs, receivedMessage]. React pone tu funci√≥n actualizadora en una cola y le proporcionar√° el par√°metro msgs en el pr√≥ximo renderizado. Es por esto que el Efecto en s√≠ ya no necesita la dependencia de messages. Como resultado de esta soluci√≥n, al recibir un mensaje de chat ya no se provocar√° que el chat se reconecte.

¬øQuieres leer un valor sin ¬´reaccionar¬ª as sus cambios?
Nota
Esta secci√≥n describe una API experimental que a√∫n no se ha a√±adido a React, por lo que a√∫n no puedes usarla.

Sup√≥n que quieres poner un sonido cuando el usuario recibe un nuevo mensaje a menos que isMuted sea true:

function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  const [isMuted, setIsMuted] = useState(false);

  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      setMessages(msgs => [...msgs, receivedMessage]);
      if (!isMuted) {
        playSound();
      }
    });
    // ...

Dado que tu Efecto ahora usa isMuted en su c√≥digo, tienes que a√±adirlo a las dependencias:

function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  const [isMuted, setIsMuted] = useState(false);

  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      setMessages(msgs => [...msgs, receivedMessage]);
      if (!isMuted) {
        playSound();
      }
    });
    return () => connection.disconnect();
  }, [roomId, isMuted]); // ‚úÖ All dependencies declared
  // ...

El problema es que cada vez que isMuted cambie (por ejemplo, cuando el usuario presiona el bot√≥n ¬´Muted¬ª), el Efecto se volver√° a sincronizar y se reconectar√° al servidor de chat. ¬°Esta no es la experiencia de usuario deseada! (En este ejemplo, a√∫n deshabilitando el linter no funcionar√≠a ‚Äîsi haces eso, isMuted se quedar√≠a ¬´atrapado¬ª en su valor antiguo‚Äî).

Para resolver este problema, necesitas extraer la l√≥gica que no debe ser reactiva fuera de tu Efecto. No quieres que este Efecto ¬´reaccione¬ª a los cambios de isMuted. Mueve este pedazo de l√≥gica a un Evento de Efecto::

import { useState, useEffect, useEffectEvent } from 'react';

function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  const [isMuted, setIsMuted] = useState(false);

  const onMessage = useEffectEvent(receivedMessage => {
    setMessages(msgs => [...msgs, receivedMessage]);
    if (!isMuted) {
      playSound();
    }
  });

  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      onMessage(receivedMessage);
    });
    return () => connection.disconnect();
  }, [roomId]); // ‚úÖ All dependencies declared
  // ...

Los Eventos de Efecto te permiten separar un Efecto en partes reactivas (que deben ¬´reaccionar¬ª a valores reactivos como roomId y sus cambios) y partes no reactivas (que solo leen sus √∫ltimos valores, como onMessage lee isMuted). Ahora que has le√≠do isMuted dentro de un Evento de Efecto, no necesita ser una dependencia de tu Efecto. Como resultado, el chat no se reconectar√° cuando cambies la configuraci√≥n ¬´Muted¬ª de on a off, ¬°solucionando el problema original!

Envolver un manejador de evento de las props 
Puede que te hayas encontrado con un problema similar en el que tu componente recibe un manejador de eventos como una prop:

function ChatRoom({ roomId, onReceiveMessage }) {
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      onReceiveMessage(receivedMessage);
    });
    return () => connection.disconnect();
  }, [roomId, onReceiveMessage]); // ‚úÖ All dependencies declared
  // ...

Sup√≥n que el componente padre pasa un funci√≥n onReceiveMessage diferente en cada renderizado:

<ChatRoom
  roomId={roomId}
  onReceiveMessage={receivedMessage => {
    // ...
  }}
/>

Dado que onReceiveMessage es una dependencia de tu Efecto, causar√≠a que el Efecto se vuelva a sincronizar despu√©s de cada rerenderizado del padre. Esto har√≠a que se reconecte al chat. Para resolver esto, envuelve la llamada en un Evento de Efecto:

function ChatRoom({ roomId, onReceiveMessage }) {
  const [messages, setMessages] = useState([]);

  const onMessage = useEffectEvent(receivedMessage => {
    onReceiveMessage(receivedMessage);
  });

  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      onMessage(receivedMessage);
    });
    return () => connection.disconnect();
  }, [roomId]); // ‚úÖ All dependencies declared
  // ...

Los Eventos de Efecto no son reactivas, por lo que no necesitas especificarlas como dependencias. Como resultado, el chat no se reconectar√° m√°s a√∫n si el componente padre pasa una funci√≥n que es diferente en cada rerenderizado.

Separar c√≥digo reactivo y c√≥digo no reactivo 
En este ejemplo, quieres registrar una visita cada vez que cambia roomId. Quieres incluir el valor actual de notificationCount con cada registro, pero no quieres que un cambio a notificationCount dispare un nuevo evento de registro.

La soluci√≥n nuevamente consiste en separar el c√≥digo no reactivo en un Evento de Efecto:

function Chat({ roomId, notificationCount }) {
  const onVisit = useEffectEvent(visitedRoomId => {
    logVisit(visitedRoomId, notificationCount);
  });

  useEffect(() => {
    onVisit(roomId);
  }, [roomId]); // ‚úÖ All dependencies declared
  // ...
}

Quieres que tu l√≥gica sea reactiva con respecto a roomId, por lo que quieres leer roomId dentro de tu Efecto. Sin embargo, no quieres que un cambio a notificationCount registre una nueva visita, por lo que lees notificationCount dentro del Evento de Efecto. Aprende m√°s sobre leer las √∫ltimas props y estado desde Efectos con el uso de Eventos de Efecto.