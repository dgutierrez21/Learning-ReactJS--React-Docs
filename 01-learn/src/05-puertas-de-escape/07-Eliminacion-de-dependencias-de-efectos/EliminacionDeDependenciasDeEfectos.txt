Eliminar dependencias de los Efectos
Cuando escribes un Efecto, el linter verificar√° que has incluido todos los valores reactivos (como las props y el estado) que tu Efecto lee en la lista de dependencias de tu Efecto. As√≠ se asegura que el Efecto se mantenga sincronizado con las √∫ltimas props y el √∫ltimo estado de tu componente. Dependencias innecesarias pueden ocasionar que tu Efecto se ejecute demasiadas veces, o incluso crear un ciclo infinito. Sigue esta gu√≠a para revisar y eliminar dependencias innecesarias de tus Efectos.

Aprender√°s
C√≥mo arreglar ciclos infinitos de dependencias de un Efecto
Qu√© hacer cuando quieres eliminar una dependencia
C√≥mo leer un valor en un Efecto sin ¬´reaccionar¬ª a √©l
C√≥mo y por qu√© evitar objectos y funciones como dependencias
Por qu√© suprimir la advertencia de la dependencia es peligroso, y qu√© hacer en su lugar

Las dependencias deben corresponderse con el c√≥digo
Cuando escribes un Efecto, primero debes especificar como iniciar y parar lo que sea que tu Efecto est√° haciendo.

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  	// ...
}

Entonces, si dejas la lista de dependencias del Efecto vac√≠a ([]), el linter sugerir√° las dependencias correctas:

...

Ll√©nalas de acuerdo a lo que dice el linter:

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ‚úÖ All dependencies declared
  // ...
}

Los Efectos ¬´reaccionar¬ª a valores reactivos. Dado que roomId es un valor reactivo (puede cambiar durante un rerenderizado), el linter verifica que lo has especificado como una dependencia. Si roomId recibe un valor diferente, React resincronizar√° tu Efecto. Esto asegura que el chat se mantiene conectado a la sala seleccionada y ¬´reacciona¬ª al dropdown:

Para eliminar una dependencia, prueba que no es una dependencia
Debes notar que no puedes ¬´escoger¬ª tus dependencias de tu Efecto. Cada valor reactivo que se usa en el c√≥digo de tu Efecto debe declararse en tu lista de dependencias. La lista de dependencias de tu Efecto est√° determinada por el c√≥digo a su alrededor:

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) { // Este es un valor reactivo
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // Este Efecto lee el valor reactivo
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ‚úÖ Por tanto debes especificar el valor reactivo como una dependencia de tu Efecto
  // ...
}

Los valores reactivos incluyen las props y todas las variables y funciones declaradas directamente dentro de componente. Dado que roomId es un valor reactivo, no puedes eliminarlo de la lista de dependencias. El linter no lo permitir√≠a:

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, []); // üî¥ React Hook useEffect has a missing dependency: 'roomId'
  // ...
}

¬°Y el linter estar√≠a en lo correcto! Dado que roomId puede cambiar con el tiempo, esto introducir√≠a un bug en tu c√≥digo.

Para eliminar una dependencias, necesitas ¬´probarle¬ª al linter que no necesita ser una dependencia. Por ejemplo, puedes mover roomId fuera de componente para probar que no es reactivo y no cambiar√° entre rerenderizados:

const serverUrl = 'https://localhost:1234';
const roomId = 'music'; // Ya no es un valor reactivo

function ChatRoom() {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => connection.disconnect();
  }, []); // ‚úÖ Se declararon todas las dependencias
  // ...
}

Ahora que roomId no es un valor reactivo (y no puede cambiar en un rerenderizado) no necesita estar como dependencia:

https://codesandbox.io/s/opk4l4?file=%2FApp.js&utm_medium=sandpack

Por esto es que ahora podemos especificar una lista de dependencias vac√≠a ([]). Tu Efecto realmente no depende y de ning√∫n valor reactivo, por lo que realmente no necesita volverse a ejecutar cuando cualquiera de las props o el estado del componente cambie.

Para cambiar las dependencias, cambia el c√≥digo
Puede que hayas notado un patr√≥n en tu flujo de trabajo:

    1. Primero, cambias el c√≥digo de tu Efecto o como se declaran los valores reactivos.
    2. Luego, sigues al linter y ajustas las dependencias para hacerlas corresponder con el c√≥digo que cambiaste.
    3. Si no est√°s a gusto con la lista de dependencias, puedes ir al primer paso (y cambiar el c√≥digo nuevamente).

La √∫ltima parte es importante. Si quieres cambiar las dependencias, cambia primero el c√≥digo que lo circunda. Puedes pensar en la lista de dependencia como una lista de todos los valores reactivos usado por el c√≥digo de tu Efecto. No eliges intencionalmente qu√© poner en esa lista. La lista describe tu c√≥digo. Para cambiar la lista de dependencia, cambia el c√≥digo.

Esto puede parecerse a resolver una ecuaci√≥n. Puedes iniciar con un objetivo (por ejemplo, eliminar una dependencia), y necesitas ¬´encontrar¬ª el c√≥digo exacto que logre ese objetivo. No todo el mundo encuentra divertido resolver ecuaciones ¬°y lo mismo podr√≠a decirse sobre escribir Efectos! Por suerte, debajo hay una lista de recetas comunes que puedes probar.

Atenci√≥n
Si tienes una base de c√≥digo existente, puede que tengas algunos Efectos que suprimen la advertencia de linter de esta forma:

useEffect(() => {
  // ...
  // üî¥ Evita suprimir as√≠ la advertencia del linter:
  // eslint-ignore-next-line react-hooks/exhaustive-dependencies
}, []);

Cuando las dependencias no se ajustan al c√≥digo, hay un riesgo muy alto de introducir bugs. Al suprimir el linter, le mientes a React sobre los valores de los que depende tu Efecto. En su lugar, usa las t√©cnicas que se muestran debajo.

Eliminar dependencias innecesarias
Cada vez que ajustas las dependencias del Efecto para reflejar el c√≥digo, mira a la lista de dependencias. ¬øTiene sentido volver a correr cuando alguna de estas dependencias cambie? A veces, la respuesta es ¬´no¬ª:

    --A veces, quieres volver a ejecutar diferentes partes de tu Efecto bajo condiciones diferentes.
    --A veces, quieres leer solo el √∫ltimo valor de alguna dependencia en lugar de ¬´reaccionar¬ª a sus cambios.
    --A veces, una dependencia puede cambiar muy a menudo de forma no intencional porque es un objeto o una funci√≥n.
    
Para encontrar la soluci√≥n correcta, necesitas responder algunas preguntas sobre tu Efecto. Revis√©moslas.

¬øDeber√≠a moverse este c√≥digo a un manejador de eventos?
Sobre lo primero que debes pensar es si este c√≥digo deber√≠a ser un Efecto.

Imagina un formulario. Al enviarse, actualizas la variable de estado submitted a true. Necesitas enviar una petici√≥n POST y mostrar una notificaci√≥n. Has decidido ubicar esta l√≥digo dentro de un Efecto que ¬´reacciona¬ª al cambio de submitted a true:

function Form() {
  const [submitted, setSubmitted] = useState(false);

  useEffect(() => {
    if (submitted) {
      // üî¥ Evita: L√≥gica espec√≠fica de Evento dentro de un Efecto
      post('/api/register');
      showNotification('Successfully registered!');
    }
  }, [submitted]);

  function handleSubmit() {
    setSubmitted(true);
  }

  // ...
}

Despu√©s, quieres estilizar el mensaje de notificaci√≥n de acuerdo al tema actual, as√≠ que lees el tema actual. Dado que theme se declara en el cuerpo del componente, es un valor reactivo, y debes declararlo como una dependencia:

function Form() {
  const [submitted, setSubmitted] = useState(false);
  const theme = useContext(ThemeContext);

  useEffect(() => {
    if (submitted) {
      // üî¥ Evita: L√≥gica espec√≠fica de Evento dentro de un Efecto
      post('/api/register');
      showNotification('Successfully registered!', theme);
    }
  }, [submitted, theme]); // ‚úÖ Todas las dependencias declaradas

  function handleSubmit() {
    setSubmitted(true);
  }  

  // ...
}

Pero al hacer esto, has introducido un bug. Imagina que env√≠as un formulario primero y luego cambias entre temas oscuros y claros. La variable theme cambiar√°, el Efecto se volver√° a ejecutar, ¬°y por tanto mostrar√° la misma notificaci√≥n nuevamente!

El problema aqu√≠ es que no debi√≥ haber sido nunca un Efecto. Quieres enviar una petici√≥n POST y mostrar la notificaci√≥n en respuesta al env√≠o del formulario, que es una interacci√≥n particular. Cuando quieres ejecutar alg√∫n c√≥digo en respuesta a una interacci√≥n particular, pon esa l√≥gica directamente en el manejador de eventos correspondiente:

function Form() {
  const theme = useContext(ThemeContext);

  function handleSubmit() {
    // ‚úÖ Bien: L√≥gica espec√≠fica de Evento se llama desde manejadores de evento
    post('/api/register');
    showNotification('Successfully registered!', theme);
  }  

  // ...
}

Ahora que el c√≥digo est√° en un manejador de evento, no es reactivo ‚Äîpor lo que solo se ejecutar√° cuando el usuario env√≠a el formulario‚Äî. Lee m√°s acerca de escoger entre manejadores de eventos y Efectos ( https://cutt.ly/o3REIA5 ) y c√≥mo eliminar Efectos innecesarios ( https://cutt.ly/93REANl )

¬øT√∫ Efecto hace varias cosas no relacionadas?
La pr√≥xima preguntas que te debes hacer es si tu Efecto est√° haciendo varias cosas no relacionadas.

Imagina que est√°s creando un formulario de env√≠os en el que el usuario necesita elegir su ciudad y √°rea. Obtienes la lista de ciudades cities del servidor de acuerdo al pa√≠s seleccionado country de forma tal que los puedas mostrar como opciones en un dropdown:

function ShippingForm({ country }) {
  const [cities, setCities] = useState(null);
  const [city, setCity] = useState(null);

  useEffect(() => {
    let ignore = false;
    fetch(`/api/cities?country=${country}`)
      .then(response => response.json())
      .then(json => {
        if (!ignore) {
          setCities(json);
        }
      });
    return () => {
      ignore = true;
    };
  }, [country]); // ‚úÖ All dependencies declared

  // ...

Este es un buen ejemplo de obtener datos en un Efecto. Est√°s sincronizando el estado cities con la red de acuerdo a la prop country. No puedes hacer esto en un manejador de eventos porque necesitas obtener los datos tan pronto como se muestre ShippingForm y cada vez que cambie country (sin importar qu√© interacciones causa el cambio).

Digamos ahora que est√°s a√±adiendo una segunda caja de selecci√≥n para las areas de la ciudad, que deber√≠a obtener las areas para la ciudad city actualmente seleccionada. Podr√≠as comenzar a√±adiendo una segunda llamada fetch para la lista de areas dentro del mismo Efecto:

function ShippingForm({ country }) {
  const [cities, setCities] = useState(null);
  const [city, setCity] = useState(null);
  const [areas, setAreas] = useState(null);

  useEffect(() => {
    let ignore = false;
    fetch(`/api/cities?country=${country}`)
      .then(response => response.json())
      .then(json => {
        if (!ignore) {
          setCities(json);
        }
      });
    // üî¥ Avoid: A single Effect synchronizes two independent processes
    if (city) {
      fetch(`/api/areas?city=${city}`)
        .then(response => response.json())
        .then(json => {
          if (!ignore) {
            setAreas(json);
          }
        });
    }
    return () => {
      ignore = true;
    };
  }, [country, city]); // ‚úÖ All dependencies declared

  // ...

Sin embargo, como ahora el Efecto usa la variable de estado city, tienes que a√±adir city a la lista de dependencias. Resulta que esto introduce un problema. Ahora, cada vez que el usuario seleccionar una ciudad diferente, el Efecto volver√° a ejecutarse y llamar a fetchCities(country). Como resultado, obtendr√°s innecesariamente la lista de ciudades muchas veces.

El problema con este c√≥digo es que est√°s sincronizando dos cosas que no guardan relaci√≥n:

    1. Quieres sincronizar el estado cities con la red con base en la prop country.
    2. Quieres sincronizar el estado areas con la red con base en el estado city.

Divide la l√≥gica en dos Efectos y cada uno reaccionar√° a la variable que necesita para sincronizarse:

function ShippingForm({ country }) {
  const [cities, setCities] = useState(null);
  useEffect(() => {
    let ignore = false;
    fetch(`/api/cities?country=${country}`)
      .then(response => response.json())
      .then(json => {
        if (!ignore) {
          setCities(json);
        }
      });
    return () => {
      ignore = true;
    };
  }, [country]); // ‚úÖ All dependencies declared

  const [city, setCity] = useState(null);
  const [areas, setAreas] = useState(null);
  useEffect(() => {
    if (city) {
      let ignore = false;
      fetch(`/api/areas?city=${city}`)
        .then(response => response.json())
        .then(json => {
          if (!ignore) {
            setAreas(json);
          }
        });
      return () => {
        ignore = true;
      };
    }
  }, [city]); // ‚úÖ All dependencies declared

  // ...

Ahora el primer Efecto solo se vuelve a ejecutar si country cambia, mientras el segundo Efecto se vuelve a ejecutar cuando city cambia. Los has separado a prop√≥sito: dos cosas diferentes se sincronizan con dos Efectos separados. Dos Efectos separados tienen dos listas de dependencias separadas, por lo que ya no se activar√°n mutuamente sin quererlo.

El c√≥digo final no es m√°s largo que el original, pero separar estos Efectos a√∫n es correcto. Cada Efecto debe representar un proceso de sincronizaci√≥n independiente. En este ejemplo, eliminar un Efecto no rompe la l√≥gica del otro Efecto. Este es un buen indicador de que sincronizan cosas diferentes, y ten√≠a sentido separarlos. Si la duplicaci√≥n te preocupa, puedes mejorar este c√≥digo a√∫n m√°s extrayendo l√≥gica repetitiva en un Hook personalizado ( https://acortar.link/GGgZCA )

¬øEst√°s leyendo alg√∫n estado para calcular el pr√≥ximo estado?
Este Efecto actualiza la variable de estado messages con un nuevo array creado cada vez que llega un nuevo mensaje:

function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      setMessages([...messages, receivedMessage]);
    });
    // ...

Usa la variable messages para crear un nuevo array que se inicia con todos los mensajes existentes y a√±ade el nuevo mensaje al final. Sin embargo, dado que messages es un valor reactivo que un Efecto lee, debe ser una dependencia:

function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      setMessages([...messages, receivedMessage]);
    });
    return () => connection.disconnect();
  }, [roomId, messages]); // ‚úÖ All dependencies declared
  // ...

Y cuando se incluye messages como dependencia se introduce un problema.

Cada vez que recibes un mensaje, setMessages() causa que el componente se vuelva a renderizar con un nuevo array messages que incluye el mensaje recibido. Sin embargo, dado que este Efecto ahora depende de messages, esto tambi√©n resincronizar√° el Efecto. Por tanto cada nuevo mensaje har√° que el chat se reconecte. ¬°El usuario no querr√≠a eso!

Para resolver el problema, no leas messages dentro del Efecto. En cambio, pasa una funci√≥n actualizadora a setMessages:

function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      setMessages(msgs => [...msgs, receivedMessage]);
    });
    return () => connection.disconnect();
  }, [roomId]); // ‚úÖ All dependencies declared
  // ...
  
Ten en cuenta que ahora el Efecto no lee para nada la variable messages. Solo necesitas pasar una funci√≥n actualizadora como msgs => [...msgs, receivedMessage]. React pone tu funci√≥n actualizadora en una cola y le proporcionar√° el par√°metro msgs en el pr√≥ximo renderizado. Es por esto que el Efecto en s√≠ ya no necesita la dependencia de messages. Como resultado de esta soluci√≥n, al recibir un mensaje de chat ya no se provocar√° que el chat se reconecte.

¬øQuieres leer un valor sin ¬´reaccionar¬ª as sus cambios?
Nota
Esta secci√≥n describe una API experimental que a√∫n no se ha a√±adido a React, por lo que a√∫n no puedes usarla.

Sup√≥n que quieres poner un sonido cuando el usuario recibe un nuevo mensaje a menos que isMuted sea true:

function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  const [isMuted, setIsMuted] = useState(false);

  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      setMessages(msgs => [...msgs, receivedMessage]);
      if (!isMuted) {
        playSound();
      }
    });
    // ...

Dado que tu Efecto ahora usa isMuted en su c√≥digo, tienes que a√±adirlo a las dependencias:

function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  const [isMuted, setIsMuted] = useState(false);

  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      setMessages(msgs => [...msgs, receivedMessage]);
      if (!isMuted) {
        playSound();
      }
    });
    return () => connection.disconnect();
  }, [roomId, isMuted]); // ‚úÖ All dependencies declared
  // ...

El problema es que cada vez que isMuted cambie (por ejemplo, cuando el usuario presiona el bot√≥n ¬´Muted¬ª), el Efecto se volver√° a sincronizar y se reconectar√° al servidor de chat. ¬°Esta no es la experiencia de usuario deseada! (En este ejemplo, a√∫n deshabilitando el linter no funcionar√≠a ‚Äîsi haces eso, isMuted se quedar√≠a ¬´atrapado¬ª en su valor antiguo‚Äî).

Para resolver este problema, necesitas extraer la l√≥gica que no debe ser reactiva fuera de tu Efecto. No quieres que este Efecto ¬´reaccione¬ª a los cambios de isMuted. Mueve este pedazo de l√≥gica a un Evento de Efecto::

import { useState, useEffect, useEffectEvent } from 'react';

function ChatRoom({ roomId }) {
  const [messages, setMessages] = useState([]);
  const [isMuted, setIsMuted] = useState(false);

  const onMessage = useEffectEvent(receivedMessage => {
    setMessages(msgs => [...msgs, receivedMessage]);
    if (!isMuted) {
      playSound();
    }
  });

  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      onMessage(receivedMessage);
    });
    return () => connection.disconnect();
  }, [roomId]); // ‚úÖ All dependencies declared
  // ...

Los Eventos de Efecto te permiten separar un Efecto en partes reactivas (que deben ¬´reaccionar¬ª a valores reactivos como roomId y sus cambios) y partes no reactivas (que solo leen sus √∫ltimos valores, como onMessage lee isMuted). Ahora que has le√≠do isMuted dentro de un Evento de Efecto, no necesita ser una dependencia de tu Efecto. Como resultado, el chat no se reconectar√° cuando cambies la configuraci√≥n ¬´Muted¬ª de on a off, ¬°solucionando el problema original!

Envolver un manejador de evento de las props 
Puede que te hayas encontrado con un problema similar en el que tu componente recibe un manejador de eventos como una prop:

function ChatRoom({ roomId, onReceiveMessage }) {
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      onReceiveMessage(receivedMessage);
    });
    return () => connection.disconnect();
  }, [roomId, onReceiveMessage]); // ‚úÖ All dependencies declared
  // ...

Sup√≥n que el componente padre pasa un funci√≥n onReceiveMessage diferente en cada renderizado:

<ChatRoom
  roomId={roomId}
  onReceiveMessage={receivedMessage => {
    // ...
  }}
/>

Dado que onReceiveMessage es una dependencia de tu Efecto, causar√≠a que el Efecto se vuelva a sincronizar despu√©s de cada rerenderizado del padre. Esto har√≠a que se reconecte al chat. Para resolver esto, envuelve la llamada en un Evento de Efecto:

function ChatRoom({ roomId, onReceiveMessage }) {
  const [messages, setMessages] = useState([]);

  const onMessage = useEffectEvent(receivedMessage => {
    onReceiveMessage(receivedMessage);
  });

  useEffect(() => {
    const connection = createConnection();
    connection.connect();
    connection.on('message', (receivedMessage) => {
      onMessage(receivedMessage);
    });
    return () => connection.disconnect();
  }, [roomId]); // ‚úÖ All dependencies declared
  // ...

Los Eventos de Efecto no son reactivas, por lo que no necesitas especificarlas como dependencias. Como resultado, el chat no se reconectar√° m√°s a√∫n si el componente padre pasa una funci√≥n que es diferente en cada rerenderizado.

Separar c√≥digo reactivo y c√≥digo no reactivo 
En este ejemplo, quieres registrar una visita cada vez que cambia roomId. Quieres incluir el valor actual de notificationCount con cada registro, pero no quieres que un cambio a notificationCount dispare un nuevo evento de registro.

La soluci√≥n nuevamente consiste en separar el c√≥digo no reactivo en un Evento de Efecto:

function Chat({ roomId, notificationCount }) {
  const onVisit = useEffectEvent(visitedRoomId => {
    logVisit(visitedRoomId, notificationCount);
  });

  useEffect(() => {
    onVisit(roomId);
  }, [roomId]); // ‚úÖ All dependencies declared
  // ...
}

Quieres que tu l√≥gica sea reactiva con respecto a roomId, por lo que quieres leer roomId dentro de tu Efecto. Sin embargo, no quieres que un cambio a notificationCount registre una nueva visita, por lo que lees notificationCount dentro del Evento de Efecto. Aprende m√°s sobre leer las √∫ltimas props y estado desde Efectos con el uso de Eventos de Efecto.

¬øAlg√∫n valor reactivo cambia inintencionadamente?
A veces, s√≠ quieres que tu Efecto reaccione a cierto valor, pero los cambios a ese valor son m√°s frecuentes de lo que quisieras ‚Äîy puede que no refleje un cambio real desde la perspectiva del usuario‚Äî. Por ejemplo, digamos que creas un objeto options en el cuerpo de tu componente, y luego lees ese objeto dentro de tu Efecto:

function ChatRoom({ roomId }) {
  // ...
  const options = {
    serverUrl: serverUrl,
    roomId: roomId
  };

  useEffect(() => {
    const connection = createConnection(options);
    connection.connect();
    // ...

Este objeto se declara en el cuerpo del componente, por lo que es un valor reactivo. Cuando lees un valor reactivo como este dentro de un Efecto, lo declaras como una dependencia. Esto garantiza que tu Efecto ¬´reacciona¬ª a sus cambios:

  // ...
  useEffect(() => {
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [options]); // ‚úÖ All dependencies declared
  // ...

¬°Es importante declararlo como una dependencia! Esto garantiza, por ejemplo, que si cambia roomId, luego tu Efecto se volver√° a conectar al chat con las nuevas opciones. Sin embargo, tambi√©n hay un problema con el c√≥digo de arriba. Para ver el problema, intenta escribir en la caja de texto del sandbox de abajo y mira que pasa en la consola:

ver ejemplo en https://codesandbox.io/s/mgmub9?file=/App.js&utm_medium=sandpack

En el sandbox de arriba, la caja de texto solo actualiza la variable de estado message. Desde la perspectiva del usuario, esto no deber√≠a afectar a la conexi√≥n del chat. Sin embargo, cada vez que actualizas la variable message, tu componente se vuelve a renderizar. Cuando tu componente rerenderiza, el c√≥digo dentro de √©l se ejecuta nuevamente.

Esto significa que se crea un nuevo objeto options en cada rerenderizado del componente ChatRoom. React ve que ese objeto options es un objeto diferente al objeto options que se cre√≥ en el renderizado anterior. Es por eso que resincroniza tu Efecto (que depende de options) y el chat se reconecta mientras escribes.

Este problema afecta a objetos y funciones en particular. En JavaScript, cada objeto y funci√≥n creado nuevamente se considera distinto a todos los dem√°s objetos. ¬°No importa si el contenido dentro de ellos puede ser el mismo!

// During the first render
const options1 = { serverUrl: 'https://localhost:1234', roomId: 'music' };

// During the next render
const options2 = { serverUrl: 'https://localhost:1234', roomId: 'music' };

// These are two different objects!
console.log(Object.is(options1, options2)); // false
Objetos y funciones como dependencias crean un riesgo de que tu Efecto se resincronice m√°s a menudo de lo que necesitas.

Es por esto que, siempre que sea posible, debes intentar evitar objetos y funciones como dependencias de los Efectos. En su lugar, intenta moverlos fuera del componente, o dentro del Efecto, o extraer valores primitivos fuera de ellos.

Mueve objetos est√°ticos y funciones fuera de tu componente
Si el objeto no depende de ninguna prop o estado, puedes mover ese objeto fuera de tu componente:

const options = {
  serverUrl: 'https://localhost:1234',
  roomId: 'music'
};

function ChatRoom() {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, []); // ‚úÖ All dependencies declared
  // ...

De esta forma, le pruebas al linter que no es reactivo. No puede cambiar como resultado de un rerenderizado, por lo que no necesita ser una dependencia de tu Efecto. Ahora si se rerenderiza ChatRoom no causar√° que se resincronice tu Efecto.

Esto tambi√©n sirve para funciones:

function createOptions() {
  return {
    serverUrl: 'https://localhost:1234',
    roomId: 'music'
  };
}

function ChatRoom() {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const options = createOptions();
    const connection = createConnection();
    connection.connect();
    return () => connection.disconnect();
  }, []); // ‚úÖ All dependencies declared
  // ...

Dado que createOptions se declara fuera del componente, no es un valor reactivo. Es por eso que no necesita especificarse en las dependencias de tu Efecto y por qu√© nunca causar√° que tu Efecto se resincronice.

Mueve objetos y funciones din√°micas dentro de tu Efecto
Si tu objeto depende de alg√∫n valor reactivo que puede cambiar como resultado de un rerenderizado, como la prop roomId, no puedes sacarlo fuera de tu component. Sin embargo, s√≠ puedes mover su creaci√≥n dentro del c√≥digo de tu Efecto:

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const options = {
      serverUrl: serverUrl,
      roomId: roomId
    };
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ‚úÖ All dependencies declared
  // ...

Ahora que options se declara dentro de tu Efecto, ya no es una dependencia de tu Efecto. En cambio, el √∫nico valor reactivo que usa tu Efecto es roomId. Dado que roomId  no es un objeto o una funci√≥n, puedes tener la seguridad de que no ser√° inintencionadamente diferente. En JavaScript, n√∫meros y cadenas se comparan por su contenido:

// During the first render
const roomId1 = 'music';

// During the next render
const roomId2 = 'music';

// These two strings are the same!
console.log(Object.is(roomId1, roomId2)); // true

Gracias a esta soluci√≥n, el chat no se reconectar√° m√°s si editas la caja de texto:

...

Sin embargo, s√≠ se reconecta cuando cambias el bot√≥n desplegable para elegir roomId, como se esperar√≠a.

Esto funciona tambi√©n para funciones:

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    function createOptions() {
      return {
        serverUrl: serverUrl,
        roomId: roomId
      };
    }

    const options = createOptions();
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [roomId]); // ‚úÖ All dependencies declared
  // ...

Puedes escribir tus propias funciones para agrupar porciones de l√≥gica dentro de tu Efecto. Siempre que las declares dentro de tu Efecto, no ser√°n valores reactivos, y por tanto no necesitan ser dependencias de tu Efecto.

Leer valores primitivos de objetos
En ocasiones, puede que recibas un objeto como prop:

function ChatRoom({ options }) {
  const [message, setMessage] = useState('');

  useEffect(() => {
    const connection = createConnection(options);
    connection.connect();
    return () => connection.disconnect();
  }, [options]); // ‚úÖ All dependencies declared
  // ...

El riesgo aqu√≠ es que el componente padre cree el objeto durante el renderizado:

<ChatRoom
  roomId={roomId}
  options={{
    serverUrl: serverUrl,
    roomId: roomId
  }}
/>

Esto causar√≠a que tu Efecto se reconectara cada vez que el componente padre se rerenderiza. Para solucionarlo, lee toda la informaci√≥n necesaria del objeto fuera del Efecto y evita tener objetos y funciones como dependencias:

function ChatRoom({ options }) {
  const [message, setMessage] = useState('');

  const { roomId, serverUrl } = options;
  useEffect(() => {
    const connection = createConnection({
      roomId: roomId,
      serverUrl: serverUrl
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, serverUrl]); // ‚úÖ All dependencies declared
  // ...

La l√≥gica se vuelve un poco repetitiva (lees algunos valores de un objeto fuera de un Efecto, y luego creas un objeto con los mismos valores dentro de un Efecto). Pero deja muy expl√≠citamente de qu√© informaci√≥n depende realmente tu Efecto. Si un objeto se vuelve a crear sin intenci√≥n por el componente padre, el chat no se reconectar√≠a. Sin embargo, si options.roomId o options.serverUrl s√≠ cambian, el chat se volver√≠a a conectar como esperar√≠as.

Calcular valores primitivos de funciones
El mismo enfoque puede servir para las funciones. Por ejemplo, sup√≥n que el componente padre pasa una funci√≥n:

<ChatRoom
  roomId={roomId}
  getOptions={() => {
    return {
      serverUrl: serverUrl,
      roomId: roomId
    };
  }}
/>

Para evitar hacerla una dependencias (y causar que se reconecte on cada rerenderizado), ll√°mala fuera del Efecto. Esto te da los valores roomId y serverUrl que no son objetos y que puedes leerlos desde dentro de tu Efecto:

function ChatRoom({ getOptions }) {
  const [message, setMessage] = useState('');

  const { roomId, serverUrl } = getOptions();
  useEffect(() => {
    const connection = createConnection({
      roomId: roomId,
      serverUrl: serverUrl
    });
    connection.connect();
    return () => connection.disconnect();
  }, [roomId, serverUrl]); // ‚úÖ All dependencies declared
  // ...

Esto solo funciona para funciones puras porque es seguro llamarlas durante el renderizado. Si tu funci√≥n es un manejador de eventos, pero no quieres que sus cambios resincronicen tu Efecto, envu√©lvela en un Evento de Efecto

Recapitulaci√≥n
  --Las dependencias siempre deben corresponderse con el c√≥digo.
  
  --Cuando no est√°s a gusto con tus dependencias, lo que necesitas editar es el c√≥digo.

  --Suprimir el linter lleva a errores confusos, y siempre deber√≠as evitarlo.

  --Para eliminar una dependencia, debes ¬´probarle¬ª al linter que no es necesaria.

  --Si el c√≥digo en tu Efecto debe ejecutarse como respuesta a una interacci√≥n espec√≠fica, mueve el c√≥digo a un manejador de eventos.

  --Si partes diferentes de tu Efecto deber√≠an volverse a ejecutar por diferentes razones, div√≠delo en diferentes Efectos.

  --Si quieres actualizar un estado basado en el estado anterior, pasa una funci√≥n actualizadora.

  --Si quieres leer el √∫ltimo valor sin ¬´reaccionar¬ª a √©l, extrae un Evento de Efecto de tu Efecto.

  --En JavaScript, los objetos y funciones se consideran diferentes si se crean en momentos diferentes.

  --Intenta evitar objetos y funciones como dependencias. Mu√©velos fuera del componente o dentro del Efecto.