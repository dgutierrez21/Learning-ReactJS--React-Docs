Es posible que no necesites un efecto
Los efectos son una escotilla de escape del paradigma React. Le permiten "salir" de React y sincronizar sus componentes con alg√∫n sistema externo como un widget que no sea React, una red o el DOM del navegador. Si no hay ning√∫n sistema externo involucrado (por ejemplo, si desea actualizar el estado de un componente cuando cambian algunos accesorios o estado), no deber√≠a necesitar un efecto. Eliminar efectos innecesarios har√° que su c√≥digo sea m√°s f√°cil de seguir, m√°s r√°pido de ejecutar y menos propenso a errores.

Aprender√°s
Por qu√© y c√≥mo eliminar efectos innecesarios de sus componentes
C√≥mo almacenar en cach√© c√°lculos costosos sin efectos
C√≥mo restablecer y ajustar el estado del componente sin efectos
C√≥mo compartir l√≥gica entre controladores de eventos
Qu√© l√≥gica se debe mover a los controladores de eventos
C√≥mo notificar a los componentes primarios sobre los cambios

C√≥mo eliminar efectos innecesarios
Hay dos casos comunes en los que no necesita efectos:

    --No necesita efectos para transformar los datos para la representaci√≥n. Por ejemplo, supongamos que desea filtrar una lista antes de mostrarla. Es posible que tenga la tentaci√≥n de escribir un efecto que actualice una variable de estado cuando cambie la lista. Sin embargo, esto es ineficiente. Cuando actualice el estado de su componente, React primero llamar√° a las funciones de su componente para calcular lo que deber√≠a estar en la pantalla. Luego, React "confirmar√°" estos cambios en el DOM, actualizando la pantalla. Entonces React ejecutar√° sus efectos. Si su efecto tambi√©n actualiza inmediatamente el estado, ¬°esto reinicia todo el proceso desde cero! Para evitar las pasadas de renderizado innecesarias, transforme todos los datos en el nivel superior de sus componentes. Ese c√≥digo se volver√° a ejecutar autom√°ticamente cada vez que cambien sus accesorios o estado.

    --No necesita Effects para gestionar los eventos de usuario. Por ejemplo, supongamos que desea enviar una solicitud /api/buy POST y mostrar una notificaci√≥n cuando el usuario compra un producto. En el controlador de eventos del bot√≥n Comprar, haga clic en usted, sabr√° exactamente lo que sucedi√≥. En el momento en que se ejecuta un efecto, no sabe qu√© hizo el usuario (por ejemplo, en qu√© bot√≥n se hizo clic). Esta es la raz√≥n por la que normalmente controlar√° los eventos de usuario en los controladores de eventos correspondientes.

Necesita efectos para sincronizar con sistemas externos. Por ejemplo, puede escribir un efecto que mantenga un widget jQuery sincronizado con el estado React. Tambi√©n puede obtener datos con Effects: por ejemplo, puede sincronizar los resultados de la b√∫squeda con la consulta de b√∫squeda actual. Tenga en cuenta que los marcos modernos proporcionan mecanismos de obtenci√≥n de datos integrados m√°s eficientes que escribir efectos directamente en sus componentes.

Para ayudarte a obtener la intuici√≥n correcta, ¬°veamos algunos ejemplos concretos comunes!

Actualizaci√≥n del estado en funci√≥n de los accesorios o el estado
Supongamos que tiene un componente con dos variables de estado: firstName y lastName. Desea calcular un fullName a partir de ellos concaten√°ndolos. Adem√°s, desea que fullName se actualice cada vez que firstName o lastName cambien. Su primer instinto podr√≠a ser agregar una variable fullName y actualizarla en un efecto:

function Form() {
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');

  // üî¥ Avoid: redundant state and unnecessary Effect
  const [fullName, setFullName] = useState('');
  useEffect(() => {
    setFullName(firstName + ' ' + lastName);
  }, [firstName, lastName]);
  // ...
}

Esto es m√°s complicado de lo necesario. Tambi√©n es ineficiente: hace una pasada de renderizado completa con un valor obsoleto para fullName, luego vuelve a renderizarse inmediatamente con el valor actualizado. Elimine tanto la variable de estado como el efecto:

function Form() {
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');
  // ‚úÖ Good: calculated during rendering
  const fullName = firstName + ' ' + lastName;
  // ...
}

Cuando algo se puede calcular a partir de los accesorios o el estado existentes, no lo pongas en estado. En su lugar, calcule durante la representaci√≥n. Esto hace que su c√≥digo sea m√°s r√°pido (evita las actualizaciones adicionales "en cascada"), m√°s simple (elimina parte del c√≥digo) y menos propenso a errores (evita que los errores causados por diferentes variables de estado no est√©n sincronizadas entre s√≠). Si este enfoque te parece nuevo, Thinking in React ( https://beta.es.reactjs.org/learn/thinking-in-react#step-3-find-the-minimal-but-complete-representation-of-ui-state ) tiene alguna orientaci√≥n sobre lo que deber√≠a entrar en el estado.

Almacenamiento en cach√© de c√°lculos costosos
Este componente calcula visibleTodos tomando los todos que recibe por props y filtr√°ndolos de acuerdo con el filter. Es posible que tenga la tentaci√≥n de almacenar el resultado en una variable de estado y actualizarlo en un efecto:

function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');

  // üî¥ Avoid: redundant state and unnecessary Effect
  const [visibleTodos, setVisibleTodos] = useState([]);
  useEffect(() => {
    setVisibleTodos(getFilteredTodos(todos, filter));
  }, [todos, filter]);

  // ...
}

Al igual que en el ejemplo anterior, esto es innecesario e ineficiente. Primero, elimine el estado y el efecto:

function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');
  // ‚úÖ This is fine if getFilteredTodos() is not slow.
  const visibleTodos = getFilteredTodos(todos, filter);
  // ...
}

En muchos casos, ¬°este c√≥digo est√° bien! Pero tal vez getFilteredTodos() es lento o tienes muchos todos. En ese caso, no desea volver a calcular getFilteredTodos() si alguna variable de estado no relacionada como newTodo ha cambiado.

Puede almacenar en cach√© (o "memoize") un c√°lculo costoso envolvi√©ndolo en un useMemo:

import { useMemo, useState } from 'react';

function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');
  const visibleTodos = useMemo(() => {
    // ‚úÖ Does not re-run unless todos or filter change
    return getFilteredTodos(todos, filter);
  }, [todos, filter]);
  // ...
}

O bien, escrito como una sola l√≠nea:

import { useMemo, useState } from 'react';

function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');
  // ‚úÖ Does not re-run getFilteredTodos() unless todos or filter change
  const visibleTodos = useMemo(() => getFilteredTodos(todos, filter), [todos, filter]);
  // ...
}

Esto le dice a React que no desea que la funci√≥n interna se vuelva a ejecutar a menos que todos o filter hayan cambiado. React recordar√° el valor devuelto de getFilteredTodos() durante el renderizado inicial. Durante los pr√≥ximos renders, comprobar√° si todos o filter son diferentes. Si son los mismos que la √∫ltima vez, useMemo devolver√° el √∫ltimo resultado que ha almacenado. Pero si son diferentes, React volver√° a llamar a la funci√≥n ajustada (y almacenar√° ese resultado en su lugar).

La funci√≥n que envuelve en useMemo se ejecuta durante la representaci√≥n, por lo que esto solo funciona para c√°lculos puros.

Restablecer todos los estados cuando cambia un accesorio
Este componente ProfilePage recibe un userId. La p√°gina contiene una entrada de comentario y se utiliza una variable de estado comment para mantener su valor. Un d√≠a, notas un problema: cuando navegas de un perfil a otro, el estado del comment no se restablece. Como resultado, es f√°cil publicar accidentalmente un comentario en el perfil de un usuario incorrecto. Para solucionar el problema, desea borrar la variable de estado de comment cada vez que cambie el userId:

export default function ProfilePage({ userId }) {
  const [comment, setComment] = useState('');

  // üî¥ Avoid: Resetting state on prop change in an Effect
  useEffect(() => {
    setComment('');
  }, [userId]);
  // ...
}

Esto es ineficaz porque ProfilePage y sus elementos secundarios se representar√°n primero con el valor obsoleto y, a continuaci√≥n, se volver√°n a procesar. Tambi√©n es complicado porque necesitar√≠a hacer esto en cada componente que tenga alg√∫n estado dentro de ProfilePage. Por ejemplo, si la interfaz de usuario de comentarios est√° anidada, tambi√©n querr√°s borrar el estado del comentario anidado.

En su lugar, puede decirle a React que el perfil de cada usuario es conceptualmente un perfil diferente d√°ndole una clave expl√≠cita. Divide tu componente en dos y pasa un atributo key del componente externo al interno:

export default function ProfilePage({ userId }) {
  return (
    <Profile
      userId={userId}
      key={userId}
    />
  );
}

function Profile({ userId }) {
  // ‚úÖ This and any other state below will reset on key change automatically
  const [comment, setComment] = useState('');
  // ...
}

Normalmente, React conserva el estado cuando el mismo componente se renderiza en el mismo lugar. Al pasar userId como key para el componente Profile, le est√° pidiendo a React que trate dos componentes de Profile con userId diferente como dos componentes diferentes que no deber√≠an compartir ning√∫n estado.Profile Cada vez que cambie la clave (que ha establecido en userId), React recrear√° el DOM y restablecer√° el estado del componente Profile y todos sus hijos. Como resultado, el campo de comment se borrar√° autom√°ticamente al navegar entre perfiles.

Tenga en cuenta que en este ejemplo, s√≥lo el componente ProfilePage externo se exporta y es visible para otros archivos del proyecto. Los componentes que representan ProfilePage no necesitan pasarle la clave: pasan userId como un accesorio normal. El hecho de ProfilePage lo pase como una key para el componente Profile es un detalle de implementaci√≥n.