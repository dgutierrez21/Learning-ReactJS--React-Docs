Es posible que no necesites un efecto
Los efectos son una escotilla de escape del paradigma React. Le permiten "salir" de React y sincronizar sus componentes con alg√∫n sistema externo como un widget que no sea React, una red o el DOM del navegador. Si no hay ning√∫n sistema externo involucrado (por ejemplo, si desea actualizar el estado de un componente cuando cambian algunos accesorios o estado), no deber√≠a necesitar un efecto. Eliminar efectos innecesarios har√° que su c√≥digo sea m√°s f√°cil de seguir, m√°s r√°pido de ejecutar y menos propenso a errores.

Aprender√°s
Por qu√© y c√≥mo eliminar efectos innecesarios de sus componentes
C√≥mo almacenar en cach√© c√°lculos costosos sin efectos
C√≥mo restablecer y ajustar el estado del componente sin efectos
C√≥mo compartir l√≥gica entre controladores de eventos
Qu√© l√≥gica se debe mover a los controladores de eventos
C√≥mo notificar a los componentes primarios sobre los cambios

C√≥mo eliminar efectos innecesarios
Hay dos casos comunes en los que no necesita efectos:

    --No necesita efectos para transformar los datos para la representaci√≥n. Por ejemplo, supongamos que desea filtrar una lista antes de mostrarla. Es posible que tenga la tentaci√≥n de escribir un efecto que actualice una variable de estado cuando cambie la lista. Sin embargo, esto es ineficiente. Cuando actualice el estado de su componente, React primero llamar√° a las funciones de su componente para calcular lo que deber√≠a estar en la pantalla. Luego, React "confirmar√°" estos cambios en el DOM, actualizando la pantalla. Entonces React ejecutar√° sus efectos. Si su efecto tambi√©n actualiza inmediatamente el estado, ¬°esto reinicia todo el proceso desde cero! Para evitar las pasadas de renderizado innecesarias, transforme todos los datos en el nivel superior de sus componentes. Ese c√≥digo se volver√° a ejecutar autom√°ticamente cada vez que cambien sus accesorios o estado.

    --No necesita Effects para gestionar los eventos de usuario. Por ejemplo, supongamos que desea enviar una solicitud /api/buy POST y mostrar una notificaci√≥n cuando el usuario compra un producto. En el controlador de eventos del bot√≥n Comprar, haga clic en usted, sabr√° exactamente lo que sucedi√≥. En el momento en que se ejecuta un efecto, no sabe qu√© hizo el usuario (por ejemplo, en qu√© bot√≥n se hizo clic). Esta es la raz√≥n por la que normalmente controlar√° los eventos de usuario en los controladores de eventos correspondientes.

Necesita efectos para sincronizar con sistemas externos. Por ejemplo, puede escribir un efecto que mantenga un widget jQuery sincronizado con el estado React. Tambi√©n puede obtener datos con Effects: por ejemplo, puede sincronizar los resultados de la b√∫squeda con la consulta de b√∫squeda actual. Tenga en cuenta que los marcos modernos proporcionan mecanismos de obtenci√≥n de datos integrados m√°s eficientes que escribir efectos directamente en sus componentes.

Para ayudarte a obtener la intuici√≥n correcta, ¬°veamos algunos ejemplos concretos comunes!

Actualizaci√≥n del estado en funci√≥n de los accesorios o el estado
Supongamos que tiene un componente con dos variables de estado: firstName y lastName. Desea calcular un fullName a partir de ellos concaten√°ndolos. Adem√°s, desea que fullName se actualice cada vez que firstName o lastName cambien. Su primer instinto podr√≠a ser agregar una variable fullName y actualizarla en un efecto:

function Form() {
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');

  // üî¥ Avoid: redundant state and unnecessary Effect
  const [fullName, setFullName] = useState('');
  useEffect(() => {
    setFullName(firstName + ' ' + lastName);
  }, [firstName, lastName]);
  // ...
}

Esto es m√°s complicado de lo necesario. Tambi√©n es ineficiente: hace una pasada de renderizado completa con un valor obsoleto para fullName, luego vuelve a renderizarse inmediatamente con el valor actualizado. Elimine tanto la variable de estado como el efecto:

function Form() {
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');
  // ‚úÖ Good: calculated during rendering
  const fullName = firstName + ' ' + lastName;
  // ...
}

Cuando algo se puede calcular a partir de los accesorios o el estado existentes, no lo pongas en estado. En su lugar, calcule durante la representaci√≥n. Esto hace que su c√≥digo sea m√°s r√°pido (evita las actualizaciones adicionales "en cascada"), m√°s simple (elimina parte del c√≥digo) y menos propenso a errores (evita que los errores causados por diferentes variables de estado no est√©n sincronizadas entre s√≠). Si este enfoque te parece nuevo, Thinking in React ( https://beta.es.reactjs.org/learn/thinking-in-react#step-3-find-the-minimal-but-complete-representation-of-ui-state ) tiene alguna orientaci√≥n sobre lo que deber√≠a entrar en el estado.

Almacenamiento en cach√© de c√°lculos costosos
Este componente calcula visibleTodos tomando los todos que recibe por props y filtr√°ndolos de acuerdo con el filter. Es posible que tenga la tentaci√≥n de almacenar el resultado en una variable de estado y actualizarlo en un efecto:

function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');

  // üî¥ Avoid: redundant state and unnecessary Effect
  const [visibleTodos, setVisibleTodos] = useState([]);
  useEffect(() => {
    setVisibleTodos(getFilteredTodos(todos, filter));
  }, [todos, filter]);

  // ...
}

Al igual que en el ejemplo anterior, esto es innecesario e ineficiente. Primero, elimine el estado y el efecto:

function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');
  // ‚úÖ This is fine if getFilteredTodos() is not slow.
  const visibleTodos = getFilteredTodos(todos, filter);
  // ...
}

En muchos casos, ¬°este c√≥digo est√° bien! Pero tal vez getFilteredTodos() es lento o tienes muchos todos. En ese caso, no desea volver a calcular getFilteredTodos() si alguna variable de estado no relacionada como newTodo ha cambiado.

Puede almacenar en cach√© (o "memoize") un c√°lculo costoso envolvi√©ndolo en un useMemo:

import { useMemo, useState } from 'react';

function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');
  const visibleTodos = useMemo(() => {
    // ‚úÖ Does not re-run unless todos or filter change
    return getFilteredTodos(todos, filter);
  }, [todos, filter]);
  // ...
}

O bien, escrito como una sola l√≠nea:

import { useMemo, useState } from 'react';

function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');
  // ‚úÖ Does not re-run getFilteredTodos() unless todos or filter change
  const visibleTodos = useMemo(() => getFilteredTodos(todos, filter), [todos, filter]);
  // ...
}

Esto le dice a React que no desea que la funci√≥n interna se vuelva a ejecutar a menos que todos o filter hayan cambiado. React recordar√° el valor devuelto de getFilteredTodos() durante el renderizado inicial. Durante los pr√≥ximos renders, comprobar√° si todos o filter son diferentes. Si son los mismos que la √∫ltima vez, useMemo devolver√° el √∫ltimo resultado que ha almacenado. Pero si son diferentes, React volver√° a llamar a la funci√≥n ajustada (y almacenar√° ese resultado en su lugar).

La funci√≥n que envuelve en useMemo se ejecuta durante la representaci√≥n, por lo que esto solo funciona para c√°lculos puros.