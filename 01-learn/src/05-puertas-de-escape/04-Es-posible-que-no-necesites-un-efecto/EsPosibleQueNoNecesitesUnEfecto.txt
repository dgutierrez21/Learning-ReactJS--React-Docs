Es posible que no necesites un efecto
Los efectos son una escotilla de escape del paradigma React. Le permiten "salir" de React y sincronizar sus componentes con alg√∫n sistema externo como un widget que no sea React, una red o el DOM del navegador. Si no hay ning√∫n sistema externo involucrado (por ejemplo, si desea actualizar el estado de un componente cuando cambian algunos accesorios o estado), no deber√≠a necesitar un efecto. Eliminar efectos innecesarios har√° que su c√≥digo sea m√°s f√°cil de seguir, m√°s r√°pido de ejecutar y menos propenso a errores.

Aprender√°s
Por qu√© y c√≥mo eliminar efectos innecesarios de sus componentes
C√≥mo almacenar en cach√© c√°lculos costosos sin efectos
C√≥mo restablecer y ajustar el estado del componente sin efectos
C√≥mo compartir l√≥gica entre controladores de eventos
Qu√© l√≥gica se debe mover a los controladores de eventos
C√≥mo notificar a los componentes primarios sobre los cambios

C√≥mo eliminar efectos innecesarios
Hay dos casos comunes en los que no necesita efectos:

    --No necesita efectos para transformar los datos para la representaci√≥n. Por ejemplo, supongamos que desea filtrar una lista antes de mostrarla. Es posible que tenga la tentaci√≥n de escribir un efecto que actualice una variable de estado cuando cambie la lista. Sin embargo, esto es ineficiente. Cuando actualice el estado de su componente, React primero llamar√° a las funciones de su componente para calcular lo que deber√≠a estar en la pantalla. Luego, React "confirmar√°" estos cambios en el DOM, actualizando la pantalla. Entonces React ejecutar√° sus efectos. Si su efecto tambi√©n actualiza inmediatamente el estado, ¬°esto reinicia todo el proceso desde cero! Para evitar las pasadas de renderizado innecesarias, transforme todos los datos en el nivel superior de sus componentes. Ese c√≥digo se volver√° a ejecutar autom√°ticamente cada vez que cambien sus accesorios o estado.

    --No necesita Effects para gestionar los eventos de usuario. Por ejemplo, supongamos que desea enviar una solicitud /api/buy POST y mostrar una notificaci√≥n cuando el usuario compra un producto. En el controlador de eventos del bot√≥n Comprar, haga clic en usted, sabr√° exactamente lo que sucedi√≥. En el momento en que se ejecuta un efecto, no sabe qu√© hizo el usuario (por ejemplo, en qu√© bot√≥n se hizo clic). Esta es la raz√≥n por la que normalmente controlar√° los eventos de usuario en los controladores de eventos correspondientes.

Necesita efectos para sincronizar con sistemas externos. Por ejemplo, puede escribir un efecto que mantenga un widget jQuery sincronizado con el estado React. Tambi√©n puede obtener datos con Effects: por ejemplo, puede sincronizar los resultados de la b√∫squeda con la consulta de b√∫squeda actual. Tenga en cuenta que los marcos modernos proporcionan mecanismos de obtenci√≥n de datos integrados m√°s eficientes que escribir efectos directamente en sus componentes.

Para ayudarte a obtener la intuici√≥n correcta, ¬°veamos algunos ejemplos concretos comunes!

Actualizaci√≥n del estado en funci√≥n de los accesorios o el estado
Supongamos que tiene un componente con dos variables de estado: firstName y lastName. Desea calcular un fullName a partir de ellos concaten√°ndolos. Adem√°s, desea que fullName se actualice cada vez que firstName o lastName cambien. Su primer instinto podr√≠a ser agregar una variable fullName y actualizarla en un efecto:

function Form() {
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');

  // üî¥ Avoid: redundant state and unnecessary Effect
  const [fullName, setFullName] = useState('');
  useEffect(() => {
    setFullName(firstName + ' ' + lastName);
  }, [firstName, lastName]);
  // ...
}

Esto es m√°s complicado de lo necesario. Tambi√©n es ineficiente: hace una pasada de renderizado completa con un valor obsoleto para fullName, luego vuelve a renderizarse inmediatamente con el valor actualizado. Elimine tanto la variable de estado como el efecto:

function Form() {
  const [firstName, setFirstName] = useState('Taylor');
  const [lastName, setLastName] = useState('Swift');
  // ‚úÖ Good: calculated during rendering
  const fullName = firstName + ' ' + lastName;
  // ...
}

Cuando algo se puede calcular a partir de los accesorios o el estado existentes, no lo pongas en estado. En su lugar, calcule durante la representaci√≥n. Esto hace que su c√≥digo sea m√°s r√°pido (evita las actualizaciones adicionales "en cascada"), m√°s simple (elimina parte del c√≥digo) y menos propenso a errores (evita que los errores causados por diferentes variables de estado no est√©n sincronizadas entre s√≠). Si este enfoque te parece nuevo, Thinking in React ( https://beta.es.reactjs.org/learn/thinking-in-react#step-3-find-the-minimal-but-complete-representation-of-ui-state ) tiene alguna orientaci√≥n sobre lo que deber√≠a entrar en el estado.

Almacenamiento en cach√© de c√°lculos costosos
Este componente calcula visibleTodos tomando los todos que recibe por props y filtr√°ndolos de acuerdo con el filter. Es posible que tenga la tentaci√≥n de almacenar el resultado en una variable de estado y actualizarlo en un efecto:

function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');

  // üî¥ Avoid: redundant state and unnecessary Effect
  const [visibleTodos, setVisibleTodos] = useState([]);
  useEffect(() => {
    setVisibleTodos(getFilteredTodos(todos, filter));
  }, [todos, filter]);

  // ...
}

Al igual que en el ejemplo anterior, esto es innecesario e ineficiente. Primero, elimine el estado y el efecto:

function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');
  // ‚úÖ This is fine if getFilteredTodos() is not slow.
  const visibleTodos = getFilteredTodos(todos, filter);
  // ...
}

En muchos casos, ¬°este c√≥digo est√° bien! Pero tal vez getFilteredTodos() es lento o tienes muchos todos. En ese caso, no desea volver a calcular getFilteredTodos() si alguna variable de estado no relacionada como newTodo ha cambiado.

Puede almacenar en cach√© (o "memoize") un c√°lculo costoso envolvi√©ndolo en un useMemo:

import { useMemo, useState } from 'react';

function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');
  const visibleTodos = useMemo(() => {
    // ‚úÖ Does not re-run unless todos or filter change
    return getFilteredTodos(todos, filter);
  }, [todos, filter]);
  // ...
}

O bien, escrito como una sola l√≠nea:

import { useMemo, useState } from 'react';

function TodoList({ todos, filter }) {
  const [newTodo, setNewTodo] = useState('');
  // ‚úÖ Does not re-run getFilteredTodos() unless todos or filter change
  const visibleTodos = useMemo(() => getFilteredTodos(todos, filter), [todos, filter]);
  // ...
}

Esto le dice a React que no desea que la funci√≥n interna se vuelva a ejecutar a menos que todos o filter hayan cambiado. React recordar√° el valor devuelto de getFilteredTodos() durante el renderizado inicial. Durante los pr√≥ximos renders, comprobar√° si todos o filter son diferentes. Si son los mismos que la √∫ltima vez, useMemo devolver√° el √∫ltimo resultado que ha almacenado. Pero si son diferentes, React volver√° a llamar a la funci√≥n ajustada (y almacenar√° ese resultado en su lugar).

La funci√≥n que envuelve en useMemo se ejecuta durante la representaci√≥n, por lo que esto solo funciona para c√°lculos puros.

Restablecer todos los estados cuando cambia un accesorio
Este componente ProfilePage recibe un userId. La p√°gina contiene una entrada de comentario y se utiliza una variable de estado comment para mantener su valor. Un d√≠a, notas un problema: cuando navegas de un perfil a otro, el estado del comment no se restablece. Como resultado, es f√°cil publicar accidentalmente un comentario en el perfil de un usuario incorrecto. Para solucionar el problema, desea borrar la variable de estado de comment cada vez que cambie el userId:

export default function ProfilePage({ userId }) {
  const [comment, setComment] = useState('');

  // üî¥ Avoid: Resetting state on prop change in an Effect
  useEffect(() => {
    setComment('');
  }, [userId]);
  // ...
}

Esto es ineficaz porque ProfilePage y sus elementos secundarios se representar√°n primero con el valor obsoleto y, a continuaci√≥n, se volver√°n a procesar. Tambi√©n es complicado porque necesitar√≠a hacer esto en cada componente que tenga alg√∫n estado dentro de ProfilePage. Por ejemplo, si la interfaz de usuario de comentarios est√° anidada, tambi√©n querr√°s borrar el estado del comentario anidado.

En su lugar, puede decirle a React que el perfil de cada usuario es conceptualmente un perfil diferente d√°ndole una clave expl√≠cita. Divide tu componente en dos y pasa un atributo key del componente externo al interno:

export default function ProfilePage({ userId }) {
  return (
    <Profile
      userId={userId}
      key={userId}
    />
  );
}

function Profile({ userId }) {
  // ‚úÖ This and any other state below will reset on key change automatically
  const [comment, setComment] = useState('');
  // ...
}

Normalmente, React conserva el estado cuando el mismo componente se renderiza en el mismo lugar. Al pasar userId como key para el componente Profile, le est√° pidiendo a React que trate dos componentes de Profile con userId diferente como dos componentes diferentes que no deber√≠an compartir ning√∫n estado.Profile Cada vez que cambie la clave (que ha establecido en userId), React recrear√° el DOM y restablecer√° el estado del componente Profile y todos sus hijos. Como resultado, el campo de comment se borrar√° autom√°ticamente al navegar entre perfiles.

Tenga en cuenta que en este ejemplo, s√≥lo el componente ProfilePage externo se exporta y es visible para otros archivos del proyecto. Los componentes que representan ProfilePage no necesitan pasarle la clave: pasan userId como un accesorio normal. El hecho de ProfilePage lo pase como una key para el componente Profile es un detalle de implementaci√≥n.

Ajustar alg√∫n estado cuando cambia un accesorio
A veces, es posible que desee restablecer o ajustar una parte del estado en un cambio de accesorios, pero no todo.

Este componente List recibe una lista de items como un accesorio y mantiene el elemento seleccionado en la variable de estado de selection. Desea restablecer la selection a null siempre que el items prop reciba una matriz diferente:

function List({ items }) {
  const [isReverse, setIsReverse] = useState(false);
  const [selection, setSelection] = useState(null);

  // üî¥ Avoid: Adjusting state on prop change in an Effect
  useEffect(() => {
    setSelection(null);
  }, [items]);
  // ...
}

Esto tampoco es lo ideal. Cada vez que cambien los items, la List y sus componentes secundarios se representar√°n con un valor selection obsoleto al principio. Luego, React actualizar√° el DOM y ejecutar√° los efectos. Finalmente, la llamada setSelection(null) provocar√° otra re-representaci√≥n de la List y sus componentes secundarios, reiniciando todo este proceso de nuevo.

Comience por eliminar el efecto. En su lugar, ajuste el estado directamente durante la representaci√≥n:

function List({ items }) {
  const [isReverse, setIsReverse] = useState(false);
  const [selection, setSelection] = useState(null);

  // Better: Adjust the state while rendering
  const [prevItems, setPrevItems] = useState(items);
  if (items !== prevItems) {
    setPrevItems(items);
    setSelection(null);
  }
  // ...
}

Almacenar informaci√≥n de renders anteriores como este puede ser dif√≠cil de entender, pero es mejor que actualizar el mismo estado en un efecto. En el ejemplo anterior, se llama a setSelection directamente durante un renderizado. React volver√° a renderizar la List inmediatamente despu√©s de que salga con una declaraci√≥n return. En ese momento, React a√∫n no ha renderizado los hijos de la lista ni actualizado el DOM, por lo que esto permite que los hijos de List omitan la representaci√≥n del valor de selection obsoleto.List

Cuando actualiza un componente durante el renderizado, React desecha el JSX devuelto e inmediatamente reintenta el renderizado. Para evitar reintentos en cascada muy lentos, React solo le permite actualizar el estado del mismo componente durante un renderizado. Si actualizas el estado de otro componente durante un procesamiento, ver√°s un error. Una condici√≥n como items !== prevItems es necesaria para evitar bucles. Puede ajustar el estado de esta manera, pero cualquier otro efecto secundario (como cambiar el DOM o establecer un tiempo de espera) debe permanecer en los controladores de eventos o efectos para mantener los componentes predecibles.

Aunque este patr√≥n es m√°s eficiente que un efecto, la mayor√≠a de los componentes tampoco deber√≠an necesitarlo. No importa c√≥mo lo haga, ajustar el estado en funci√≥n de los accesorios u otro estado hace que su flujo de datos sea m√°s dif√≠cil de entender y depurar. Siempre verifique si puede restablecer todos los estados con una clave o calcular todo durante el procesamiento. Por ejemplo, en lugar de almacenar (y restablecer) el elemento seleccionado, puede almacenar el ID del elemento seleccionado:

function List({ items }) {
  const [isReverse, setIsReverse] = useState(false);
  const [selectedId, setSelectedId] = useState(null);
  // ‚úÖ Best: Calculate everything during rendering
  const selection = items.find(item => item.id === selectedId) ?? null;
  // ...
}

Ahora no hay necesidad de "ajustar" el estado en absoluto. Si el elemento con el ID seleccionado est√° en la lista, permanece seleccionado. Si no es as√≠, la selection calculada durante la representaci√≥n ser√° null porque no se encontr√≥ ning√∫n elemento coincidente. Este comportamiento es un poco diferente, pero podr√≠a decirse que es mejor porque la mayor√≠a de los cambios en items ahora conservan la selecci√≥n. Sin embargo, necesitar√≠a usar la selection en toda la l√≥gica siguiente porque es posible que no exista un elemento con selectedId.

Uso compartido de l√≥gica entre controladores de eventos
Digamos que tiene una p√°gina de producto con dos botones (Comprar y Pagar) que le permiten comprar ese producto. Desea mostrar una notificaci√≥n cada vez que el usuario ponga el producto en el carrito. Agregar la llamada showNotification() a los controladores de clic de ambos botones se siente repetitivo, por lo que podr√≠a sentirse tentado a colocar esta l√≥gica en un efecto:

function ProductPage({ product, addToCart }) {
  // üî¥ Avoid: Event-specific logic inside an Effect
  useEffect(() => {
    if (product.isInCart) {
      showNotification(`Added ${product.name} to the shopping cart!`);
    }
  }, [product]);

  function handleBuyClick() {
    addToCart(product);
  }

  function handleCheckoutClick() {
    addToCart(product);
    navigateTo('/checkout');
  }
  // ...
}

Este efecto es innecesario. Tambi√©n es muy probable que cause errores. Por ejemplo, supongamos que su aplicaci√≥n "recuerda" el carrito de compras entre las recargas de la p√°gina. Si agrega un producto al carrito una vez y actualiza la p√°gina, la notificaci√≥n volver√° a aparecer. Seguir√° apareciendo cada vez que actualice la p√°gina de ese producto. Esto se debe a que product.isInCart ya ser√° true en la carga de la p√°gina, por lo que el efecto anterior llamar√° a showNotification().

Cuando no est√© seguro de si alg√∫n c√≥digo debe estar en un efecto o en un controlador de eventos, preg√∫ntese por qu√© debe ejecutarse este c√≥digo. Utilice Efectos s√≥lo para el c√≥digo que debe ejecutarse porque el componente se mostr√≥ al usuario. En este ejemplo, la notificaci√≥n deber√≠a aparecer porque el usuario presion√≥ el bot√≥n, no porque se mostrara la p√°gina. Elimine el efecto y coloque la l√≥gica compartida en una funci√≥n a la que llame desde ambos controladores de eventos:

function ProductPage({ product, addToCart }) {
  // ‚úÖ Good: Event-specific logic is called from event handlers
  function buyProduct() {
    addToCart(product);
    showNotification(`Added ${product.name} to the shopping cart!`);
  }

  function handleBuyClick() {
    buyProduct();
  }

  function handleCheckoutClick() {
    buyProduct();
    navigateTo('/checkout');
  }
  // ...
}

Esto elimina el efecto innecesario y corrige el error.

Env√≠o de una solicitud POST
Este componente Form env√≠a dos tipos de solicitudes POST. Env√≠a un evento de an√°lisis cuando se monta. Cuando complete el formulario y haga clic en el bot√≥n Enviar, enviar√° una solicitud POST al punto de enlace //api/register:

function Form() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');

  // ‚úÖ Good: This logic should run because the component was displayed
  useEffect(() => {
    post('/analytics/event', { eventName: 'visit_form' });
  }, []);

  // üî¥ Avoid: Event-specific logic inside an Effect
  const [jsonToSubmit, setJsonToSubmit] = useState(null);
  useEffect(() => {
    if (jsonToSubmit !== null) {
      post('/api/register', jsonToSubmit);
    }
  }, [jsonToSubmit]);

  function handleSubmit(e) {
    e.preventDefault();
    setJsonToSubmit({ firstName, lastName });
  }
  // ...
}

Apliquemos los mismos criterios que en el ejemplo anterior.

La solicitud POST de an√°lisis debe permanecer en un efecto. Esto se debe a que el motivo para enviar el evento de an√°lisis es que se mostr√≥ el formulario. (Se disparar√≠a dos veces en desarrollo, pero vea aqu√≠ c√≥mo lidiar con eso).

Sin embargo, la solicitud /api/register POST no est√° causada por el formulario que se muestra. Solo desea enviar la solicitud en un momento espec√≠fico: cuando el usuario presiona el bot√≥n. Solo deber√≠a suceder en esa interacci√≥n en particular. Elimine el segundo efecto y mueva esa solicitud POST al controlador de eventos:

function Form() {
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');

  // ‚úÖ Good: This logic runs because the component was displayed
  useEffect(() => {
    post('/analytics/event', { eventName: 'visit_form' });
  }, []);

  function handleSubmit(e) {
    e.preventDefault();
    // ‚úÖ Good: Event-specific logic is in the event handler
    post('/api/register', { firstName, lastName });
  }
  // ...
}

Cuando elige si desea poner algo de l√≥gica en un controlador de eventos o en un efecto, la pregunta principal que debe responder es qu√© tipo de l√≥gica es desde la perspectiva del usuario. Si esta l√≥gica est√° causada por una interacci√≥n determinada, mant√©ngala en el controlador de eventos. Si es causado por el usuario que ve el componente en la pantalla, mant√©ngalo en el Efecto.

Cadenas de c√°lculos
A veces puede sentirse tentado a encadenar efectos que ajustan cada uno un fragmento de estado basado en otro estado:

function Game() {
  const [card, setCard] = useState(null);
  const [goldCardCount, setGoldCardCount] = useState(0);
  const [round, setRound] = useState(1);
  const [isGameOver, setIsGameOver] = useState(false);

  // üî¥ Avoid: Chains of Effects that adjust the state solely to trigger each other
  useEffect(() => {
    if (card !== null && card.gold) {
      setGoldCardCount(c => c + 1);
    }
  }, [card]);

  useEffect(() => {
    if (goldCardCount > 3) {
      setRound(r => r + 1)
      setGoldCardCount(0);
    }
  }, [goldCardCount]);

  useEffect(() => {
    if (round > 5) {
      setIsGameOver(true);
    }
  }, [round]);

  useEffect(() => {
    alert('Good game!');
  }, [isGameOver]);

  function handlePlaceCard(nextCard) {
    if (isGameOver) {
      throw Error('Game already ended.');
    } else {
      setCard(nextCard);
    }
  }

  // ...

Hay dos problemas con este c√≥digo.

Un problema es que es muy ineficiente: el componente (y sus hijos) tienen que volver a renderizarse entre cada llamada set en la cadena. En el ejemplo anterior, en el peor de los casos (setCard ‚Üí render ‚Üí setCard ‚Üí render ‚Üí setRound ‚Üí render ‚Üí setGoldCardCount setIsGameOver ‚Üí renderizar) hay tres re-renders innecesarios del √°rbol de abajo. setRound

Incluso si no fuera lento, a medida que su c√≥digo evoluciona, se encontrar√° con casos en los que la "cadena" que escribi√≥ no se ajusta a los nuevos requisitos. Imagina que est√°s agregando una forma de recorrer la historia de los movimientos del juego. Lo har√≠a actualizando cada variable de estado a un valor del pasado. Sin embargo, establecer el estado de la card en un valor del pasado volver√≠a a activar la cadena de efectos y cambiar√≠a los datos que est√° mostrando. El c√≥digo como este es a menudo r√≠gido y fr√°gil.

En este caso, es mejor calcular lo que puede durante la representaci√≥n y ajustar el estado en el controlador de eventos:

function Game() {
  const [card, setCard] = useState(null);
  const [goldCardCount, setGoldCardCount] = useState(0);
  const [round, setRound] = useState(1);

  // ‚úÖ Calculate what you can during rendering
  const isGameOver = round > 5;

  function handlePlaceCard(nextCard) {
    if (isGameOver) {
      throw Error('Game already ended.');
    }

    // ‚úÖ Calculate all the next state in the event handler
    setCard(nextCard);
    if (nextCard.gold) {
      if (goldCardCount <= 3) {
        setGoldCardCount(goldCardCount + 1);
      } else {
        setGoldCardCount(0);
        setRound(round + 1);
        if (round === 5) {
          alert('Good game!');
        }
      }
    }
  }

  // ...

Esto es mucho m√°s eficiente. Adem√°s, si implementas una forma de ver el historial del juego, ahora podr√°s establecer cada variable de estado en un movimiento del pasado sin activar la cadena de efectos que ajusta todos los dem√°s valores. Si necesita reutilizar la l√≥gica entre varios controladores de eventos, puede extraer una funci√≥n y llamarla desde esos controladores.

Recuerde que dentro de los controladores de eventos, el estado se comporta como una instant√°nea. Por ejemplo, incluso despu√©s de llamar a setRound(round + 1) la variable round reflejar√° el valor en el momento en que el usuario hizo clic en el bot√≥n. Si necesita usar el siguiente valor para los c√°lculos, def√≠nalo manualmente como const nextRound = round + 1.

En algunos casos, no puede calcular el siguiente estado directamente en el controlador de eventos. Por ejemplo, imagine un formulario con varios men√∫s desplegables donde las opciones del siguiente men√∫ desplegable dependen del valor seleccionado del men√∫ desplegable anterior. A continuaci√≥n, una cadena de datos de obtenci√≥n de efectos es apropiada porque se est√° sincronizando con la red.