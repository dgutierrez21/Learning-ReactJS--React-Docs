Ciclo de vida de los efectos reactivos
Los efectos tienen un ciclo de vida diferente al de los componentes. Los componentes pueden montarse, actualizarse o desmontarse. Un efecto solo puede hacer dos cosas: comenzar a sincronizar algo y, m√°s tarde, dejar de sincronizarlo. Este ciclo puede ocurrir varias veces si su efecto depende de los accesorios y el estado que cambia con el tiempo. React proporciona una regla de linter para comprobar que ha especificado correctamente las dependencias de su efecto. Esto mantiene tu efecto sincronizado con los √∫ltimos accesorios y estados.

Aprender√°s
En qu√© se diferencia el ciclo de vida de un efecto del ciclo de vida de un componente
C√≥mo pensar en cada efecto individual de forma aislada
Cu√°ndo es necesario volver a sincronizar Effect y por qu√©
C√≥mo se determinan las dependencias de su efecto
Qu√© significa que un valor sea reactivo
Qu√© significa una matriz de dependencias vac√≠a
C√≥mo React verifica que sus dependencias son correctas con un linter
Qu√© hacer cuando no est√°s de acuerdo con el linter

El ciclo de vida de un efecto
Cada componente de React pasa por el mismo ciclo de vida:

    --Un componente se monta cuando se agrega a la pantalla.
    --Un componente se actualiza cuando recibe nuevos accesorios o estado. Esto generalmente sucede en respuesta a una interacci√≥n.
    --Un componente se desmonta cuando se retira de la pantalla.

Es una buena manera de pensar en componentes, pero no en efectos. En su lugar, intente pensar en cada efecto independientemente del ciclo de vida de su componente. Un efecto describe c√≥mo sincronizar un sistema externo con los accesorios y el estado actuales. A medida que cambie el c√≥digo, esta sincronizaci√≥n tendr√° que ocurrir con m√°s o menos frecuencia.

Para ilustrar este punto, considere este efecto de conexi√≥n del componente a un servidor de chat:

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]);
  // ...
}

El cuerpo de tu efecto especifica c√≥mo iniciar la sincronizaci√≥n:
    // ...
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
    // ...

La funci√≥n de limpieza devuelta por el efecto especifica c√≥mo detener la sincronizaci√≥n:
    // ...
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
    // ...

Intuitivamente, podr√≠a pensar que React comenzar√≠a a sincronizarse cuando su componente se monta y dejar√≠a de sincronizarse cuando su componente se desmonta. Sin embargo, ¬°este no es el final de la historia! A veces, tambi√©n puede ser necesario iniciar y detener la sincronizaci√≥n varias veces mientras el componente permanece montado.

Veamos por qu√© esto es necesario, cu√°ndo sucede y c√≥mo puede controlar este comportamiento.

Nota
Algunos efectos no devuelven una funci√≥n de limpieza en absoluto. La mayor√≠a de las veces, querr√° devolver uno, pero si no lo hace, React se comportar√° como si devolviera una funci√≥n de limpieza vac√≠a que no hace nada.

Por qu√© puede ser necesario realizar la sincronizaci√≥n m√°s de una vez
Imagine que este componente ChatRoom recibe un accesorio roomId que el usuario selecciona en un men√∫ desplegable. Digamos que inicialmente el usuario elige la sala ""general" como roomId. La aplicaci√≥n muestra el sal√≥n de chat "general":

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId /* "general" */ }) {
  // ...
  return <h1>Welcome to the {roomId} room!</h1>;
}

Despu√©s de que se muestre la interfaz de usuario, React ejecutar√° su efecto para comenzar a sincronizar. Se conecta a la sala "general":

function ChatRoom({ roomId /* "general" */ }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // Connects to the "general" room
    connection.connect();
    return () => {
      connection.disconnect(); // Disconnects from the "general" room
    };
  }, [roomId]);
  // ...

Hasta ahora, bien.

M√°s tarde, el usuario elige una habitaci√≥n diferente en el men√∫ desplegable (por ejemplo, "travel" Primero, React actualizar√° la interfaz de usuario:

function ChatRoom({ roomId /* "travel" */ }) {
  // ...
  return <h1>Welcome to the {roomId} room!</h1>;
}

Haga una pausa para pensar en lo que deber√≠a suceder a continuaci√≥n. El usuario ve que ""travel" es el sal√≥n de chat seleccionado en la interfaz de usuario. Sin embargo, el efecto que se ejecut√≥ la √∫ltima vez todav√≠a est√° conectado a la sala "general" El prop roomId ha cambiado, por lo que lo que sea que tu efecto haya hecho en ese entonces (conectarse a la sala "general" ya no coincide con la interfaz de usuario.

En este punto, desea que React haga dos cosas:

    1. Detener la sincronizaci√≥n con el roomId antiguo (desconectarse de la sala "general"
    2. Comience a sincronizar con el nuevo roomId (con√©ctese a la sala "travel"
    
¬°Afortunadamente, ya le has ense√±ado a React c√≥mo hacer ambas cosas! El cuerpo del efecto especifica c√≥mo iniciar la sincronizaci√≥n y la funci√≥n de limpieza especifica c√≥mo detener la sincronizaci√≥n. Todo lo que React necesita hacer ahora es llamarlos en el orden correcto y con los accesorios y el estado correctos. Veamos c√≥mo sucede exactamente eso.

C√≥mo React vuelve a sincronizar tu efecto
Recuerde que su componente ChatRoom ha recibido un nuevo valor para su prop roomId. Sol√≠a ser ""general" y ahora es "travel" React necesita volver a sincronizar tu efecto para volver a conectarte a una habitaci√≥n diferente.

Para detener la sincronizaci√≥n, React llamar√° a la funci√≥n de limpieza que su efecto devolvi√≥ despu√©s de conectarse a la habitaci√≥n "general" Dado que roomId era "general", la funci√≥n de limpieza se desconecta de la sala "general":"general"

function ChatRoom({ roomId /* "general" */ }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // Connects to the "general" room
    connection.connect();
    return () => {
      connection.disconnect(); // Disconnects from the "general" room
    };
    // ...
    
Luego, React ejecutar√° el efecto que ha proporcionado durante este renderizado. Esta vez, roomId es "travel", por lo que comenzar√° a sincronizarse con la sala de chat "travel" (hasta que finalmente se llame tambi√©n a su funci√≥n de limpieza):"travel"

function ChatRoom({ roomId /* "travel" */ }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // Connects to the "travel" room
    connection.connect();
    // ...

Gracias a esto, ahora est√° conectado a la misma habitaci√≥n que el usuario eligi√≥ en la interfaz de usuario. ¬°Desastre evitado!

Cada vez que el componente se vuelva a renderizar con un roomId diferente, el efecto se volver√° a sincronizar. Por ejemplo, supongamos que el usuario cambia roomId de ""travel"" a "music" React volver√° a dejar de sincronizar tu efecto llamando a su funci√≥n de limpieza (desconect√°ndote de la sala de "travel" Luego comenzar√° a sincronizarse nuevamente ejecutando su cuerpo con el nuevo accesorio roomId (que lo conecta a la sala "music"").

Finalmente, cuando el usuario va a una pantalla diferente, ChatRoom se desmonta. Ahora no hay necesidad de permanecer conectado en absoluto. React dejar√° de sincronizar su efecto por √∫ltima vez y lo desconectar√° de la sala de chat de "music"

Pensar desde la perspectiva del efecto
Recapitulemos todo lo que ha sucedido desde la perspectiva del componente ChatRoom:

    1. ChatRoom montada con roomId establecido en ""general"
    2. ChatRoom actualizada con roomId configurado para ""travel"
    3. ChatRoom actualizada con roomId configurado en ""music"
    4. ChatRoom desmontada

Durante cada uno de estos puntos del ciclo de vida del componente, su efecto hizo cosas diferentes:

    1. Su efecto conectado a la sala ""general"
    2. Su efecto desconectado de la sala ""general"" y conectado a la sala ""travel"
    3. Su efecto se desconect√≥ de la sala de ""travel"" y se conect√≥ a la sala de ""music"
    4. Tu efecto desconectado de la sala "music"
    Ahora pensemos en lo que sucedi√≥ desde la perspectiva del Efecto mismo:

  useEffect(() => {
    // Your Effect connected to the room specified with roomId...
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      // ...until it disconnected
      connection.disconnect();
    };
  }, [roomId]);

La estructura de este c√≥digo podr√≠a inspirarle a ver lo que sucedi√≥ como una secuencia de per√≠odos de tiempo no superpuestos:

    1. Su efecto conectado a la habitaci√≥n ""general" (hasta que se desconect√≥)
    2. Su efecto conectado a la sala "travel" (hasta que se desconect√≥)
    3. Su efecto conectado a la sala "music" (hasta que se desconect√≥)

Anteriormente, estabas pensando desde la perspectiva del componente. Cuando se miraba desde la perspectiva del componente, era tentador pensar en los efectos como "devoluciones de llamada" o "eventos del ciclo de vida" que se activan en un momento espec√≠fico como "despu√©s de un renderizado" o "antes de desmontar". Esta forma de pensar se complica muy r√°pido, por lo que es mejor evitarla.

En su lugar, conc√©ntrese siempre en un solo ciclo de inicio / parada a la vez. No deber√≠a importar si un componente se est√° montando, actualizando o desmontando. Todo lo que necesita hacer es describir c√≥mo iniciar la sincronizaci√≥n y c√≥mo detenerla. Si lo haces bien, tu efecto ser√° resistente a ser iniciado y detenido tantas veces como sea necesario.

Esto podr√≠a recordarle c√≥mo no piensa si un componente se est√° montando o actualizando cuando escribe la l√≥gica de representaci√≥n que crea JSX. Usted describe lo que deber√≠a estar en la pantalla, y React resuelve el resto.

C√≥mo verifica React que tu efecto puede volver a sincronizarse
Aqu√≠ hay un ejemplo en vivo con el que puedes jugar. Presione "Abrir chat" para montar el componente ChatRoom:

...

Observe que cuando el componente se monta por primera vez, ver√° tres registros:

1. ‚úÖ Connecting to "general" room at https://localhost:1234... (solo desarrollo)
2. ‚ùå Disconnected from "general" room at https://localhost:1234. (solo desarrollo)
3. ‚úÖ Connecting to "general" room at https://localhost:1234...

Los dos primeros registros son s√≥lo de desarrollo. En el desarrollo, React siempre vuelve a montar cada componente una vez. En otras palabras, React verifica que su efecto puede volver a sincronizarse forz√°ndolo a hacerlo inmediatamente en el desarrollo. Esto podr√≠a recordarle c√≥mo puede abrir la puerta y cerrarla un tiempo adicional para verificar que la cerradura de la puerta funcione. React inicia y detiene tu efecto una vez m√°s en desarrollo para comprobar que has implementado bien su limpieza.

La raz√≥n principal por la que su efecto se volver√° a sincronizar en la pr√°ctica es si algunos datos que utiliza han cambiado. En el espacio aislado anterior, cambie el sal√≥n de chat seleccionado. Observe c√≥mo, cuando cambia roomId, su efecto se vuelve a sincronizar.

Sin embargo, tambi√©n hay casos m√°s inusuales en los que es necesaria la resincronizaci√≥n. Por ejemplo, intente editar serverUrl en el espacio aislado anterior mientras el chat est√° abierto. Observe c√≥mo el efecto se vuelve a sincronizar en respuesta a las ediciones del c√≥digo. En el futuro, React puede agregar m√°s funciones que aprovechen la resincronizaci√≥n.

C√≥mo sabe React que necesita volver a sincronizar el efecto
Es posible que se pregunte c√≥mo React sab√≠a que su efecto necesitaba volver a sincronizarse despu√©s de los cambios roomId. Es porque le dijiste a React que el c√≥digo de este efecto depende de roomId al incluirlo en la lista de dependencias:

function ChatRoom({ roomId }) { // The roomId prop may change over time
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // This Effect reads roomId 
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]); // So you tell React that this Effect "depends on" roomId
  // ...

As√≠ es como funciona esto:

    1. Sab√≠as que roomId es un accesorio, lo que significa que puede cambiar con el tiempo.
    2. Sab√≠as que tu efecto lee roomId (por lo que su l√≥gica depende de un valor que puede cambiar m√°s adelante).
    3. Esta es la raz√≥n por la que lo especific√≥ como dependencia de su efecto (para que se vuelva a sincronizar cuando cambie roomId).

Cada vez que su componente se vuelva a renderizar, React mirar√° la matriz de dependencias que ha pasado. Si alguno de los valores de la matriz es diferente del valor en el mismo lugar que pas√≥ durante el renderizado anterior, React volver√° a sincronizar su efecto. Por ejemplo, si pasaste ["general"] durante el renderizado inicial, y luego pasaste ["travel"] durante el siguiente renderizado, React comparar√° ""general"" y ["general"] "travel"["travel"] Estos son valores diferentes (en comparaci√≥n con Object.is), por lo que React volver√° a sincronizar su efecto. Por otro lado, si el componente se vuelve a renderizar pero roomId no ha cambiado, el efecto permanecer√° conectado a la misma habitaci√≥n.

Cada efecto representa un proceso de sincronizaci√≥n independiente
Resista agregar l√≥gica no relacionada a su efecto solo porque esta l√≥gica debe ejecutarse al mismo tiempo que un efecto que ya escribi√≥. Por ejemplo, supongamos que desea enviar un evento de an√°lisis cuando el usuario visita la sala. Ya tiene un efecto que depende de roomId, por lo que puede sentirse tentado a agregar la llamada de an√°lisis all√≠ mismo:

function ChatRoom({ roomId }) {
  useEffect(() => {
    logVisit(roomId);
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]);
  // ...
}

Pero imagina que m√°s tarde agregas otra dependencia a este Efecto que necesita restablecer la conexi√≥n. Si este efecto se vuelve a sincronizar, tambi√©n llamar√° a logVisit(roomId) para la misma sala, lo que no pretend√≠a. Registrar la visita es un proceso separado de la conexi√≥n. Es por eso que deben escribirse como dos efectos separados:

function ChatRoom({ roomId }) {
  useEffect(() => {
    logVisit(roomId);
  }, [roomId]);

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    // ...
  }, [roomId]);
  // ...
}

Cada efecto del c√≥digo debe representar un proceso de sincronizaci√≥n independiente e independiente.

En el ejemplo anterior, eliminar un efecto no romper√≠a la l√≥gica del otro efecto. Esta es una buena indicaci√≥n de que sincronizan diferentes cosas, por lo que ten√≠a sentido dividirlas. Por otro lado, si divide una pieza cohesiva de l√≥gica en efectos separados, el c√≥digo puede parecer "m√°s limpio" pero ser√° m√°s dif√≠cil de mantener. Es por eso que debe pensar si los procesos son iguales o separados, no si el c√≥digo se ve m√°s limpio.

Los efectos "reaccionan" a los valores reactivos
El efecto lee dos variables (serverUrl y roomId), pero s√≥lo ha especificado roomId como dependencia:

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]);
  // ...
}

¬øPor qu√© serverUrl no necesita ser una dependencia?

Esto se debe a que serverUrl nunca cambia debido a un reprocesamiento. Siempre es el mismo sin importar cu√°ntas veces y con qu√© accesorios y estado el componente se vuelve a renderizar. Dado que serverUrl nunca cambia, no tendr√≠a sentido especificarlo como una dependencia. Despu√©s de todo, ¬°las dependencias solo hacen algo cuando cambian con el tiempo!

Por otro lado, roomId puede ser diferente en un re-renderizado. Los accesorios, el estado y otros valores declarados dentro del componente son reactivos porque se calculan durante la representaci√≥n y participan en el flujo de datos de React.

Si serverUrl fuera una variable de estado, ser√≠a reactiva. Los valores reactivos deben incluirse en las dependencias:

function ChatRoom({ roomId }) { // Props change over time
  const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // State may change over time

  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // Your Effect reads props and state
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId, serverUrl]); // So you tell React that this Effect "depends on" on props and state
  // ...
}

Al incluir serverUrl como dependencia, se asegura de que el efecto se vuelva a sincronizar despu√©s de que cambie.

Intente cambiar el sal√≥n de chat seleccionado o edite la URL del servidor en este espacio aislado:

...

Cada vez que cambia un valor reactivo como roomId o serverUrl, el efecto se vuelve a conectar al servidor de chat.

Qu√© significa un efecto con dependencias vac√≠as
¬øQu√© sucede si mueve serverUrl y roomId fuera del componente?

const serverUrl = 'https://localhost:1234';
const roomId = 'general';

function ChatRoom() {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, []); // ‚úÖ All dependencies declared
  // ...
}

Ahora el c√≥digo de su efecto no utiliza ning√∫n valor reactivo, por lo que sus dependencias pueden estar vac√≠as ([]).

Si piensa desde la perspectiva del componente, la matriz de dependencias [] vac√≠a significa que este efecto se conecta al sal√≥n de chat solo cuando se monta el componente y se desconecta solo cuando el componente se desmonta. (Tenga en cuenta que React a√∫n lo volver√≠a a sincronizar un tiempo adicional en desarrollo para probar la l√≥gica de su efecto).

Sin embargo, si piensas desde la perspectiva del Efecto, no necesitas pensar en montar y desmontar en absoluto. Lo importante es que has especificado lo que hace tu efecto para iniciar y detener la sincronizaci√≥n. Hoy en d√≠a, no tiene dependencias reactivas. Pero si alguna vez desea que el usuario cambie roomId o serverUrl con el tiempo (por lo que tendr√≠a que volverse reactivo), el c√≥digo de su efecto no cambiar√°. Solo necesitar√°s agregarlos a las dependencias.

Todas las variables declaradas en el cuerpo del componente son reactivas
Los accesorios y el estado no son los √∫nicos valores reactivos. Los valores que se calculan a partir de ellos tambi√©n son reactivos. Si los accesorios o el estado cambian, el componente se volver√° a representar y los valores calculados a partir de ellos tambi√©n cambiar√°n. Esta es la raz√≥n por la que todas las variables del cuerpo del componente utilizado por el efecto tambi√©n deben estar en la lista de dependencias del efecto.

Digamos que el usuario puede elegir un servidor de chat en el men√∫ desplegable, pero tambi√©n puede configurar un servidor predeterminado en la configuraci√≥n. Supongamos que ya ha puesto el estado de configuraci√≥n en un contexto para que lea la settings de ese contexto. Ahora calcula serverUrl en funci√≥n del servidor seleccionado a partir de props y el servidor predeterminado a partir del contexto:

function ChatRoom({ roomId, selectedServerUrl }) { // roomId is reactive
  const settings = useContext(SettingsContext); // settings is reactive
  const serverUrl = selectedServerUrl ?? settings.defaultServerUrl; // serverUrl is reactive
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // Your Effect reads roomId and serverUrl
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId, serverUrl]); // So it needs to re-synchronize when either of them changes!
  // ...
}

En este ejemplo, serverUrl no es un prop o una variable de estado. Es una variable regular que se calcula durante el renderizado. Pero se calcula durante el renderizado, por lo que puede cambiar debido a un nuevo renderizado. Por eso es reactivo.

Todos los valores dentro del componente (incluidos los accesorios, el estado y las variables en el cuerpo del componente) son reactivos. Cualquier valor reactivo puede cambiar en un reprocesamiento, por lo que debe incluir valores reactivos como dependencias de Effect.

En otras palabras, los efectos "reaccionan" a todos los valores del cuerpo componente.

React verifica que haya especificado cada valor reactivo como una dependencia
Si su linter est√° configurado para React, comprobar√° que cada valor reactivo utilizado por el c√≥digo de su efecto se declara como su dependencia. Por ejemplo, este es un error de lint porque tanto roomId como serverUrl son reactivos:

https://beta.reactjs.org/learn/lifecycle-of-reactive-effects#react-verifies-that-you-specified-every-reactive-value-as-a-dependency

Esto puede parecer un error de React, pero realmente React est√° se√±alando un error en su c√≥digo. Tanto roomId como serverUrl pueden cambiar con el tiempo, pero olvidas volver a sincronizar tu efecto cuando cambian. Como resultado, permanecer√° conectado a roomId y serverUrl iniciales incluso despu√©s de que el usuario elija valores diferentes en la interfaz de usuario.

Para corregir el error, siga la sugerencia del linter para especificar roomId y serverUrl como dependencias de su efecto:

function ChatRoom({ roomId, serverUrl }) {
  const [serverUrl, setServerUrl] = useState('https://localhost:1234'); // serverUrl is reactive
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [serverUrl, roomId]); // ‚úÖ All dependencies declared
  // ...
}

Pruebe esta soluci√≥n en el entorno de pruebas anterior. Verifique que el error linter haya desaparecido y que el chat se vuelva a conectar cuando sea necesario.

Nota
En algunos casos, React sabe que un valor nunca cambia aunque est√© declarado dentro del componente. Por ejemplo, la funci√≥n set devuelta por useState y el objeto ref devuelto por useRef son estables: se garantiza que no cambiar√°n en una nueva representaci√≥n. Los valores estables no son reactivos, por lo que el linter le permite omitirlos de la lista. Sin embargo, incluirlos est√° permitido: no cambiar√°n, as√≠ que no importa.

Qu√© hacer cuando no desea volver a sincronizar
En el ejemplo anterior, ha corregido el error lint enumerando roomId y serverUrl como dependencias.

Sin embargo, en su lugar podr√≠a "probar" al linter que estos valores no son valores reactivos, es decir, que no pueden cambiar como resultado de un re-renderizado. Por ejemplo, si serverUrl y roomId no dependen de la representaci√≥n y siempre tienen los mismos valores, puede moverlos fuera del componente. Ahora no necesitan ser dependencias:

const serverUrl = 'https://localhost:1234'; // serverUrl is not reactive
const roomId = 'general'; // roomId is not reactive

function ChatRoom() {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, []); // ‚úÖ All dependencies declared
  // ...
}

Tambi√©n puedes moverlos dentro del efecto. No se calculan durante el renderizado, por lo que no son reactivos:

function ChatRoom() {
  useEffect(() => {
    const serverUrl = 'https://localhost:1234'; // serverUrl is not reactive
    const roomId = 'general'; // roomId is not reactive
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, []); // ‚úÖ All dependencies declared
  // ...
}

Los efectos son bloques de c√≥digo reactivos. Se vuelven a sincronizar cuando cambian los valores que lees dentro de ellos. A diferencia de los controladores de eventos, que solo se ejecutan una vez por interacci√≥n, Effects se ejecuta siempre que la sincronizaci√≥n es necesaria.

No puedes "elegir" tus dependencias. Las dependencias deben incluir todos los valores reactivos que lea en el efecto. El linter hace cumplir esto. A veces, esto puede provocar problemas como bucles infinitos y que su efecto se vuelva a sincronizar con demasiada frecuencia. ¬°No solucione estos problemas suprimiendo el linter! Esto es lo que puedes probar en su lugar:

  --Compruebe que su efecto representa un proceso de sincronizaci√≥n independiente. Si tu efecto no sincroniza nada, puede que no sea necesario. Si sincroniza varias cosas independientes, div√≠delo.

  --Si desea leer el √∫ltimo valor de los accesorios o el estado sin "reaccionar" a √©l y volver a sincronizar el efecto, puede dividir su efecto en una parte reactiva (que mantendr√° en el efecto) y una parte no reactiva (que extraer√° en algo llamado funci√≥n de evento). Obtenga m√°s informaci√≥n sobre c√≥mo separar eventos de efectos.

  --Evite confiar en objetos y funciones como dependencias. Si crea objetos y funciones durante el procesamiento y luego los lee desde un efecto, ser√°n diferentes en cada procesamiento. Esto har√° que tu efecto se vuelva a sincronizar cada vez. Obt√©n m√°s informaci√≥n sobre c√≥mo eliminar dependencias innecesarias de tus efectos.

Atenci√≥n
El linter es tu amigo, pero sus poderes son limitados. El linter solo sabe cu√°ndo las dependencias son incorrectas. No sabe la mejor manera de resolver cada caso. Si el linter sugiere una dependencia, pero agregarlo causa un bucle, no significa que el linter deba ignorarse. Significa que necesita cambiar el c√≥digo dentro (o fuera) del efecto para que ese valor no sea reactivo y no necesite ser una dependencia.

Si tiene una base de c√≥digo existente, es posible que tenga algunos efectos que supriman el linter como este:

useEffect(() => {
  // ...
  // üî¥ Avoid suppressing the linter like this:
  // eslint-ignore-next-line react-hooks/exhaustive-dependencies
}, []);

En las p√°ginas siguientes, aprender√° c√≥mo corregir este c√≥digo sin romper las reglas. ¬°Siempre vale la pena arreglarlo!