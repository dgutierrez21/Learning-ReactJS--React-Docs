Ciclo de vida de los efectos reactivos
Los efectos tienen un ciclo de vida diferente al de los componentes. Los componentes pueden montarse, actualizarse o desmontarse. Un efecto solo puede hacer dos cosas: comenzar a sincronizar algo y, más tarde, dejar de sincronizarlo. Este ciclo puede ocurrir varias veces si su efecto depende de los accesorios y el estado que cambia con el tiempo. React proporciona una regla de linter para comprobar que ha especificado correctamente las dependencias de su efecto. Esto mantiene tu efecto sincronizado con los últimos accesorios y estados.

Aprenderás
En qué se diferencia el ciclo de vida de un efecto del ciclo de vida de un componente
Cómo pensar en cada efecto individual de forma aislada
Cuándo es necesario volver a sincronizar Effect y por qué
Cómo se determinan las dependencias de su efecto
Qué significa que un valor sea reactivo
Qué significa una matriz de dependencias vacía
Cómo React verifica que sus dependencias son correctas con un linter
Qué hacer cuando no estás de acuerdo con el linter

El ciclo de vida de un efecto
Cada componente de React pasa por el mismo ciclo de vida:

    --Un componente se monta cuando se agrega a la pantalla.
    --Un componente se actualiza cuando recibe nuevos accesorios o estado. Esto generalmente sucede en respuesta a una interacción.
    --Un componente se desmonta cuando se retira de la pantalla.

Es una buena manera de pensar en componentes, pero no en efectos. En su lugar, intente pensar en cada efecto independientemente del ciclo de vida de su componente. Un efecto describe cómo sincronizar un sistema externo con los accesorios y el estado actuales. A medida que cambie el código, esta sincronización tendrá que ocurrir con más o menos frecuencia.

Para ilustrar este punto, considere este efecto de conexión del componente a un servidor de chat:

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
  }, [roomId]);
  // ...
}

El cuerpo de tu efecto especifica cómo iniciar la sincronización:
    // ...
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
    // ...

La función de limpieza devuelta por el efecto especifica cómo detener la sincronización:
    // ...
    const connection = createConnection(serverUrl, roomId);
    connection.connect();
    return () => {
      connection.disconnect();
    };
    // ...

Intuitivamente, podría pensar que React comenzaría a sincronizarse cuando su componente se monta y dejaría de sincronizarse cuando su componente se desmonta. Sin embargo, ¡este no es el final de la historia! A veces, también puede ser necesario iniciar y detener la sincronización varias veces mientras el componente permanece montado.

Veamos por qué esto es necesario, cuándo sucede y cómo puede controlar este comportamiento.

Nota
Algunos efectos no devuelven una función de limpieza en absoluto. La mayoría de las veces, querrá devolver uno, pero si no lo hace, React se comportará como si devolviera una función de limpieza vacía que no hace nada.

Por qué puede ser necesario realizar la sincronización más de una vez
Imagine que este componente ChatRoom recibe un accesorio roomId que el usuario selecciona en un menú desplegable. Digamos que inicialmente el usuario elige la sala ""general" como roomId. La aplicación muestra el salón de chat "general":

const serverUrl = 'https://localhost:1234';

function ChatRoom({ roomId /* "general" */ }) {
  // ...
  return <h1>Welcome to the {roomId} room!</h1>;
}

Después de que se muestre la interfaz de usuario, React ejecutará su efecto para comenzar a sincronizar. Se conecta a la sala "general":

function ChatRoom({ roomId /* "general" */ }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // Connects to the "general" room
    connection.connect();
    return () => {
      connection.disconnect(); // Disconnects from the "general" room
    };
  }, [roomId]);
  // ...

Hasta ahora, bien.

Más tarde, el usuario elige una habitación diferente en el menú desplegable (por ejemplo, "travel" Primero, React actualizará la interfaz de usuario:

function ChatRoom({ roomId /* "travel" */ }) {
  // ...
  return <h1>Welcome to the {roomId} room!</h1>;
}

Haga una pausa para pensar en lo que debería suceder a continuación. El usuario ve que ""travel" es el salón de chat seleccionado en la interfaz de usuario. Sin embargo, el efecto que se ejecutó la última vez todavía está conectado a la sala "general" El prop roomId ha cambiado, por lo que lo que sea que tu efecto haya hecho en ese entonces (conectarse a la sala "general" ya no coincide con la interfaz de usuario.

En este punto, desea que React haga dos cosas:

    1. Detener la sincronización con el roomId antiguo (desconectarse de la sala "general"
    2. Comience a sincronizar con el nuevo roomId (conéctese a la sala "travel"
    
¡Afortunadamente, ya le has enseñado a React cómo hacer ambas cosas! El cuerpo del efecto especifica cómo iniciar la sincronización y la función de limpieza especifica cómo detener la sincronización. Todo lo que React necesita hacer ahora es llamarlos en el orden correcto y con los accesorios y el estado correctos. Veamos cómo sucede exactamente eso.

Cómo React vuelve a sincronizar tu efecto
Recuerde que su componente ChatRoom ha recibido un nuevo valor para su prop roomId. Solía ser ""general" y ahora es "travel" React necesita volver a sincronizar tu efecto para volver a conectarte a una habitación diferente.

Para detener la sincronización, React llamará a la función de limpieza que su efecto devolvió después de conectarse a la habitación "general" Dado que roomId era "general", la función de limpieza se desconecta de la sala "general":"general"

function ChatRoom({ roomId /* "general" */ }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // Connects to the "general" room
    connection.connect();
    return () => {
      connection.disconnect(); // Disconnects from the "general" room
    };
    // ...
    
Luego, React ejecutará el efecto que ha proporcionado durante este renderizado. Esta vez, roomId es "travel", por lo que comenzará a sincronizarse con la sala de chat "travel" (hasta que finalmente se llame también a su función de limpieza):"travel"

function ChatRoom({ roomId /* "travel" */ }) {
  useEffect(() => {
    const connection = createConnection(serverUrl, roomId); // Connects to the "travel" room
    connection.connect();
    // ...

Gracias a esto, ahora está conectado a la misma habitación que el usuario eligió en la interfaz de usuario. ¡Desastre evitado!

Cada vez que el componente se vuelva a renderizar con un roomId diferente, el efecto se volverá a sincronizar. Por ejemplo, supongamos que el usuario cambia roomId de ""travel"" a "music" React volverá a dejar de sincronizar tu efecto llamando a su función de limpieza (desconectándote de la sala de "travel" Luego comenzará a sincronizarse nuevamente ejecutando su cuerpo con el nuevo accesorio roomId (que lo conecta a la sala "music"").

Finalmente, cuando el usuario va a una pantalla diferente, ChatRoom se desmonta. Ahora no hay necesidad de permanecer conectado en absoluto. React dejará de sincronizar su efecto por última vez y lo desconectará de la sala de chat de "music"