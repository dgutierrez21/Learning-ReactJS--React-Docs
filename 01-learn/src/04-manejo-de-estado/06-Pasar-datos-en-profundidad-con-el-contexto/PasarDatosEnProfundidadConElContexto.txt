Pasar datos profundamente con contexto
Por lo general, pasará información de un componente padre a un componente secundario a través de accesorios. Pero pasar accesorios puede volverse detallado e inconveniente si tienes que pasarlos a través de muchos componentes en el medio, o si muchos componentes de tu aplicación necesitan la misma información. El contexto permite que el componente padre ponga cierta información a disposición de cualquier componente del árbol debajo de él, sin importar cuán profundo sea, sin pasarla explícitamente a través de accesorios.

Aprenderás
Qué es la "perforación de apoyo"
Cómo reemplazar el paso repetitivo de accesorios con contexto
Casos de uso comunes para el contexto
Alternativas comunes al contexto

El problema de pasar props
Pasar accesorios es una excelente manera de canalizar explícitamente datos a través del árbol de la interfaz de usuario a los componentes que lo usan.

Pero pasar accesorios puede volverse detallado e inconveniente cuando necesita pasar algunos accesorios profundamente a través del árbol, o si muchos componentes necesitan el mismo accesorio. El ancestro común más cercano podría estar muy alejado de los componentes que necesitan datos, y elevar el estado tan alto puede conducir a una situación a veces llamada "perforación de apoyo".

ver imagen...

¿No sería genial si hubiera una manera de "teletransportar" datos a los componentes del árbol que los necesitan sin pasar accesorios? Con la función de contexto de React, ¡hay!

Context: una alternativa a los accesorios de paso
El contexto permite que un componente padre proporcione datos a todo el árbol debajo de él. Hay muchos usos para el contexto. He aquí un ejemplo. Considere este componente Heading que acepta un level para su tamaño:

...

Supongamos que desea que varios encabezados dentro de la misma Section tengan siempre el mismo tamaño:

...

Actualmente, pasas el accesorio level a cada <Heading> por separado:

<Section>
  <Heading level={3}>About</Heading>
  <Heading level={3}>Photos</Heading>
  <Heading level={3}>Videos</Heading>
</Section>

Sería bueno si pudieras pasar el accesorio de level al componente <Section>> en su lugar y eliminarlo del <Heading>. De esta manera, podría exigir que todos los encabezados de la misma sección tengan el mismo tamaño:

<Section level={3}>
  <Heading>About</Heading>
  <Heading>Photos</Heading>
  <Heading>Videos</Heading>
</Section>

Pero, ¿cómo puede el componente <Heading>> conocer el nivel de su <Section> más cercano? Eso requeriría alguna forma para que un niño "pida" datos de algún lugar arriba en el árbol.

No puedes hacerlo solo con accesorios. Aquí es donde entra en juego el contexto. Lo harás en tres pasos:

1. Crear un contexto. (Puede llamarlo LevelContext, ya que es para el nivel de encabezado).

2. Utilice ese contexto del componente que necesita los datos. (Heading usará LevelContext.)

3. Proporcione ese contexto desde el componente que especifica los datos. (Section proporcionará LevelContext.)

El contexto permite que un padre, ¡incluso uno distante!, proporcione algunos datos a todo el árbol dentro de él.

ver imagen...

Paso 1: Crear el contexto
Primero, necesitas crear el contexto. Deberá exportarlo desde un archivo para que sus componentes puedan usarlo:

...

El único argumento para createContext es el valor predeterminado. Aquí, 1 se refiere al nivel de encabezado más grande, pero puede pasar cualquier tipo de valor (incluso un objeto). Verá la importancia del valor predeterminado en el siguiente paso.

Paso 2: Usa el contexto 
Importa el useContext desde React y tu contexto:

...

Actualmente, el componente Heading lee el level de los accesorios:

...

En su lugar, quite el accesorio de level y lea el valor del contexto que acaba de importar, LevelContext:

...

useContext es un gancho. Al igual que useState y useReducer, solo puede llamar a un Hook en el nivel superior de un componente React. useContext indica a React que el componente Heading desea leer LevelContext.

Ahora que el componente Encabezado no tiene un accesorio de nivel, ya no es necesario pasar el puntal de level a Heading en Heading su JSX

Ahora que el componente Encabezado no tiene un accesorio de nivel, ya no es necesario pasar el puntal de level a Heading en Heading su JSX de esta manera:

Actualice el JSX para que sea la Section la que lo reciba en su lugar.

...

¡Observe que este ejemplo aún no funciona! Todos los encabezados tienen el mismo tamaño porque, aunque esté utilizando el contexto, aún no lo ha proporcionado. ¡React no sabe dónde conseguirlo!

Si no proporciona el contexto, React utilizará el valor predeterminado que especificó en el paso anterior. En este ejemplo, especificó 1 como argumento para createContext, por lo que useContext(LevelContext) devuelve 1, estableciendo todos 1esos encabezados en <h1>. Solucionemos este problema haciendo que cada Section proporcione su propio contexto.

Paso 3: Proporcionar el contexto
El componente Section actualmente representa sus elementos secundarios.

Envuélvalos con un proveedor de contexto para proporcionarles LevelContext:

...

Esto le dice a React: "si algún componente dentro <Section> solicita LevelContext, dales este level". El componente usará el valor del <LevelContext.Provider> más cercano en el árbol de la interfaz de usuario que se encuentra encima.

Es el mismo resultado que el código original, ¡pero no fue necesario pasar el accesorio de level a cada componente Heading! En cambio, "calcula" su nivel de encabezado preguntando a la Section más cercana anterior:

1. Pasas un accesorio level a la <Section>.
2. Section ajusta sus elementos secundarios en <LevelContext.Provider value={level}>.
3. Heading pregunta el valor más cercano de LevelContext anterior con useContext(LevelContext) LevelContext.