Conservar y reiniciar el estado
El estado está aislado entre los componentes. React mantiene un registro de qué estado pertenece a qué componente basándose en su lugar en el árbol de la interfaz de usuario (UI). Puedes controlar cuándo conservar el estado y cuándo restablecerlo entre rerenderizados.

Aprenderás
Cómo React “ve” las estructuras de los componentes
Cuándo React elige preservar o reiniciar el estado
Cómo forzar a React a restablecer el estado del componente
Cómo las claves y los tipos afectan a la preservación del estado

El árbol de la UI 
Los navegadores utilizan muchas estructuras de árbol para modelar la interfaz de usuario. El DOM representa los elementos HTML, el CSSOM hace lo mismo con el CSS. ¡Hay incluso un  árbol de accesibilidad!

React también utiliza estructuras de árbol para gestionar y modelar la UI que estás generando. React crea árboles de UI a partir de su JSX. Posteriormente, React DOM actualiza los elementos del DOM del navegador para que coincidan con ese árbol UI. (React Native traduce estos árboles en elementos específicos para plataformas móviles).

ver imagen...

El estado está ligado a una posición en el árbol
Cuando se le da un estado a un componente, se podría pensar que el estado "vive" dentro del componente. Pero el estado en realidad está dentro de React. React asocia cada parte de estado que contiene con el componente correcto por donde se encuentra ese componente en el árbol de la interfaz de usuario.

Aquí, solo hay una etiqueta JSX <Counter />, pero se representa en dos posiciones diferentes:

...

Así es como se ven como un árbol:

ver imagen...

Estos son dos contadores separados porque cada uno se representa en su propia posición en el árbol. Por lo general, no tiene que pensar en estas posiciones para usar React, pero puede ser útil para comprender cómo funciona.

En React, cada componente de la pantalla tiene un estado completamente aislado. Por ejemplo, si procesa dos componentes de Counter uno al lado del otro, cada uno de ellos obtendrá sus propios estados independientes, de score y hover.

Intente hacer clic en ambos contadores y observe que no se afectan entre sí:

...

Como puede ver, cuando se actualiza un contador, solo se actualiza el estado de ese componente:

ver imagen...

React mantendrá el estado durante el tiempo que renderice el mismo componente en la misma posición. Para ver esto, incremente ambos contadores, luego elimine el segundo componente desmarcando la casilla de verificación "Renderizar el segundo contador" y luego agréguelo nuevamente marcándola:

ver contador02...

Observe cómo en el momento en que deja de representar el segundo contador, su estado desaparece por completo. Esto se debe a que cuando React elimina un componente, destruye su estado.

ver imagen...

Cuando marca "Renderizar el segundo contador", un segundo Counter y su estado se inicializan desde cero (score = 0) y se agregan al DOM.

ver imagen...

React conserva el estado de un componente mientras se representa en su posición en el árbol de la interfaz de usuario. Si se elimina, o un componente diferente se procesa en la misma posición, React descarta su estado.

El mismo componente en la misma posición conserva el estado
En este ejemplo, hay dos etiquetas <Counter /> diferentes:

ver contador03...

Al marcar o desactivar la casilla de verificación, el estado del contador no se restablece. Ya sea isFancy sea true o false, siempre tiene un <Counter /> como el primer hijo del div devuelto desde el componente raíz de la App:

ver imagen...

Es el mismo componente en la misma posición, por lo que, desde la perspectiva de React, es el mismo contador.

Trampa
Recuerde que es la posición en el árbol de la interfaz de usuario, no en el marcado JSX, lo que importa para react. Este componente tiene dos cláusulas return con diferentes etiquetas <Counter /> dentro y fuera del if:

https://codesandbox.io/s/omf2o9?file=/App.js&utm_medium=sandpack

Puede esperar que el estado se restablezca cuando marque la casilla de verificación, ¡pero no es así! Esto se debe a que ambas etiquetas <Counter /> se representan en la misma posición. React no sabe dónde colocas las condiciones en tu función. Todo lo que "ve" es el árbol que devuelves. En ambos casos, el componente App devuelve un <<div>> con <Counter /> como primer hijo. Es por eso que React los considera como los mismos <Counter />.

Puedes pensar que tienen la misma "dirección": el primer hijo del primer hijo de la raíz. Así es como React los compara entre los renders anterior y siguiente, independientemente de cómo estructure su lógica.

Diferentes componentes en el mismo estado de restablecimiento de posición
En este ejemplo, al marcar la casilla de verificación, se reemplazará <<Counter>> por una <p>:

...

Aquí, puede cambiar entre diferentes tipos de componentes en la misma posición. Inicialmente, el primer hijo del <div> contenía un Counter. Pero cuando cambiaste una p, React eliminó el Counter del árbol de la interfaz de usuario y destruyó su estado.

ver imagen...

Como regla general, si desea preservar el estado entre re-renders, la estructura de su árbol debe "coincidir" de un renderizado a otro. Si la estructura es diferente, el estado se destruye porque React destruye el estado cuando elimina un componente del árbol.

Trampa
Esta es la razón por la que no debe anidar definiciones de funciones de componentes.

Aquí, la función del componente MyTextField se define dentro de MyComponent:

https://codesandbox.io/s/48dzyh?file=/App.js&utm_medium=sandpack

¡Cada vez que hace clic en el botón, el estado de entrada desaparece! Esto se debe a que se crea una función MyTextField diferente para cada representación de MyComponent. Estás renderizando un componente diferente en la misma posición, por lo que React restablece todos los estados a continuación. Esto conduce a errores y problemas de rendimiento. Para evitar este problema, declare siempre las funciones de los componentes en el nivel superior y no anide sus definiciones.